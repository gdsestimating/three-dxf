!function(t,n){"object"==typeof exports&&"object"==typeof module?module.exports=n(require("THREE")):"function"==typeof define&&define.amd?define(["THREE"],n):"object"==typeof exports?exports.ThreeDxf=n(require("THREE")):t.ThreeDxf=n(t.THREE)}("undefined"!=typeof self?self:this,function(__WEBPACK_EXTERNAL_MODULE__0__){return function(t){var n={};function c(e){if(n[e])return n[e].exports;var g=n[e]={i:e,l:!1,exports:{}};return t[e].call(g.exports,g,g.exports,c),g.l=!0,g.exports}return c.m=t,c.c=n,c.d=function(t,n,e){c.o(t,n)||Object.defineProperty(t,n,{enumerable:!0,get:e})},c.r=function(t){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})},c.t=function(t,n){if(1&n&&(t=c(t)),8&n)return t;if(4&n&&"object"==typeof t&&t&&t.__esModule)return t;var e=Object.create(null);if(c.r(e),Object.defineProperty(e,"default",{enumerable:!0,value:t}),2&n&&"string"!=typeof t)for(var g in t)c.d(e,g,function(n){return t[n]}.bind(null,g));return e},c.n=function(t){var n=t&&t.__esModule?function(){return t.default}:function(){return t};return c.d(n,"a",n),n},c.o=function(t,n){return Object.prototype.hasOwnProperty.call(t,n)},c.p="",c(c.s=1)}([function(module,exports){eval("module.exports = __WEBPACK_EXTERNAL_MODULE__0__;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9UaHJlZUR4Zi9leHRlcm5hbCBcIlRIUkVFXCI/ZmMwMCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSIsImZpbGUiOiIwLmpzIiwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX18wX187Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///0\n")},function(module,__webpack_exports__,__webpack_require__){"use strict";eval("__webpack_require__.r(__webpack_exports__);\n\n// EXTERNAL MODULE: external \"THREE\"\nvar external_THREE_ = __webpack_require__(0);\n\n// CONCATENATED MODULE: ./src/OrbitControls.js\n/**\r\n * @author qiao / https://github.com/qiao\r\n * @author mrdoob / http://mrdoob.com\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author WestLangley / http://github.com/WestLangley\r\n * @author erich666 / http://erichaines.com\r\n */\r\n/*global THREE, console */\r\n\r\n// This set of controls performs orbiting, dollying (zooming), and panning. It maintains\r\n// the \"up\" direction as +Y, unlike the TrackballControls. Touch on tablet and phones is\r\n// supported.\r\n//\r\n//    Orbit - left mouse / touch: one finger move\r\n//    Zoom - middle mouse, or mousewheel / touch: two finger spread or squish\r\n//    Pan - right mouse, or arrow keys / touch: three finter swipe\r\n//\r\n// This is a drop-in replacement for (most) TrackballControls used in examples.\r\n// That is, include this js file and wherever you see:\r\n//    \tcontrols = new THREE.TrackballControls( camera );\r\n//      controls.target.z = 150;\r\n// Simple substitute \"OrbitControls\" and the control should work as-is.\r\n\r\n\r\n\r\nfunction OrbitControls( object, domElement ) {\r\n\r\n\tthis.object = object;\r\n\tthis.domElement = ( domElement !== undefined ) ? domElement : document;\r\n\r\n\t// API\r\n\r\n\t// Set to false to disable this control\r\n\tthis.enabled = true;\r\n\r\n\t// \"target\" sets the location of focus, where the control orbits around\r\n\t// and where it pans with respect to.\r\n\tthis.target = new external_THREE_[\"Vector3\"]();\r\n\r\n\t// center is old, deprecated; use \"target\" instead\r\n\tthis.center = this.target;\r\n\r\n\t// This option actually enables dollying in and out; left as \"zoom\" for\r\n\t// backwards compatibility\r\n\tthis.noZoom = false;\r\n\tthis.zoomSpeed = 1.0;\r\n\r\n\t// Limits to how far you can dolly in and out\r\n\tthis.minDistance = 0;\r\n\tthis.maxDistance = Infinity;\r\n\r\n\t// Set to true to disable this control\r\n\tthis.noRotate = false;\r\n\tthis.rotateSpeed = 1.0;\r\n\r\n\t// Set to true to disable this control\r\n\tthis.noPan = false;\r\n\tthis.keyPanSpeed = 7.0;\t// pixels moved per arrow key push\r\n\r\n\t// Set to true to automatically rotate around the target\r\n\tthis.autoRotate = false;\r\n\tthis.autoRotateSpeed = 2.0; // 30 seconds per round when fps is 60\r\n\r\n\t// How far you can orbit vertically, upper and lower limits.\r\n\t// Range is 0 to Math.PI radians.\r\n\tthis.minPolarAngle = 0; // radians\r\n\tthis.maxPolarAngle = Math.PI; // radians\r\n\r\n\t// Set to true to disable use of the keys\r\n\tthis.noKeys = false;\r\n\r\n\t// The four arrow keys\r\n\tthis.keys = { LEFT: 37, UP: 38, RIGHT: 39, BOTTOM: 40 };\r\n\r\n\t////////////\r\n\t// internals\r\n\r\n\tvar scope = this;\r\n\r\n\tvar EPS = 0.000001;\r\n\r\n\tvar rotateStart = new external_THREE_[\"Vector2\"]();\r\n\tvar rotateEnd = new external_THREE_[\"Vector2\"]();\r\n\tvar rotateDelta = new external_THREE_[\"Vector2\"]();\r\n\r\n\tvar panStart = new external_THREE_[\"Vector2\"]();\r\n\tvar panEnd = new external_THREE_[\"Vector2\"]();\r\n\tvar panDelta = new external_THREE_[\"Vector2\"]();\r\n\tvar panOffset = new external_THREE_[\"Vector3\"]();\r\n\r\n\tvar offset = new external_THREE_[\"Vector3\"]();\r\n\r\n\tvar dollyStart = new external_THREE_[\"Vector2\"]();\r\n\tvar dollyEnd = new external_THREE_[\"Vector2\"]();\r\n\tvar dollyDelta = new external_THREE_[\"Vector2\"]();\r\n\r\n\tvar phiDelta = 0;\r\n\tvar thetaDelta = 0;\r\n\tvar scale = 1;\r\n\tvar pan = new external_THREE_[\"Vector3\"]();\r\n\r\n\tvar lastPosition = new external_THREE_[\"Vector3\"]();\r\n\r\n\tvar STATE = { NONE : -1, ROTATE : 0, DOLLY : 1, PAN : 2, TOUCH_ROTATE : 3, TOUCH_DOLLY : 4, TOUCH_PAN : 5 };\r\n\r\n\tvar state = STATE.NONE;\r\n\r\n\t// for reset\r\n\r\n\tthis.target0 = this.target.clone();\r\n\tthis.position0 = this.object.position.clone();\r\n\r\n\t// events\r\n\r\n\tvar changeEvent = { type: 'change' };\r\n\tvar startEvent = { type: 'start'};\r\n\tvar endEvent = { type: 'end'};\r\n\r\n\tthis.rotateLeft = function ( angle ) {\r\n\r\n\t\tif ( angle === undefined ) {\r\n\r\n\t\t\tangle = getAutoRotationAngle();\r\n\r\n\t\t}\r\n\r\n\t\tthetaDelta -= angle;\r\n\r\n\t};\r\n\r\n\tthis.rotateUp = function ( angle ) {\r\n\r\n\t\tif ( angle === undefined ) {\r\n\r\n\t\t\tangle = getAutoRotationAngle();\r\n\r\n\t\t}\r\n\r\n\t\tphiDelta -= angle;\r\n\r\n\t};\r\n\r\n\t// pass in distance in world space to move left\r\n\tthis.panLeft = function ( distance ) {\r\n\r\n\t\tvar te = this.object.matrix.elements;\r\n\r\n\t\t// get X column of matrix\r\n\t\tpanOffset.set( te[ 0 ], te[ 1 ], te[ 2 ] );\r\n\t\tpanOffset.multiplyScalar( - distance );\r\n\t\t\r\n\t\tpan.add( panOffset );\r\n\r\n\t};\r\n\r\n\t// pass in distance in world space to move up\r\n\tthis.panUp = function ( distance ) {\r\n\r\n\t\tvar te = this.object.matrix.elements;\r\n\r\n\t\t// get Y column of matrix\r\n\t\tpanOffset.set( te[ 4 ], te[ 5 ], te[ 6 ] );\r\n\t\tpanOffset.multiplyScalar( distance );\r\n\t\t\r\n\t\tpan.add( panOffset );\r\n\r\n\t};\r\n\t\r\n\t// pass in x,y of change desired in pixel space,\r\n\t// right and down are positive\r\n\tthis.pan = function ( deltaX, deltaY ) {\r\n\r\n\t\tvar element = scope.domElement === document ? scope.domElement.body : scope.domElement;\r\n\r\n\t\tif ( scope.object.fov !== undefined ) {\r\n\r\n\t\t\t// perspective\r\n\t\t\tvar position = scope.object.position;\r\n\t\t\tvar offset = position.clone().sub( scope.target );\r\n\t\t\tvar targetDistance = offset.length();\r\n\r\n\t\t\t// half of the fov is center to top of screen\r\n\t\t\ttargetDistance *= Math.tan( ( scope.object.fov / 2 ) * Math.PI / 180.0 );\r\n\r\n\t\t\t// we actually don't use screenWidth, since perspective camera is fixed to screen height\r\n\t\t\tscope.panLeft( 2 * deltaX * targetDistance / element.clientHeight );\r\n\t\t\tscope.panUp( 2 * deltaY * targetDistance / element.clientHeight );\r\n\r\n\t\t} else if ( scope.object.top !== undefined ) {\r\n            \r\n\t\t\t// orthographic\r\n\t\t\tscope.panLeft( deltaX * (scope.object.right - scope.object.left) / element.clientWidth );\r\n\t\t\tscope.panUp( deltaY * (scope.object.top - scope.object.bottom) / element.clientHeight );\r\n\r\n\t\t} else {\r\n\r\n\t\t\t// camera neither orthographic or perspective\r\n\t\t\tconsole.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - pan disabled.' );\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tthis.dollyIn = function ( dollyScale ) {\r\n\r\n\t\tif ( dollyScale === undefined ) {\r\n\r\n\t\t\tdollyScale = getZoomScale();\r\n\r\n\t\t}\r\n\r\n\t\tscale /= dollyScale;\r\n\r\n\t};\r\n\r\n\tthis.dollyOut = function ( dollyScale ) {\r\n\r\n\t\tif ( dollyScale === undefined ) {\r\n\r\n\t\t\tdollyScale = getZoomScale();\r\n\r\n\t\t}\r\n\r\n\t\tscale *= dollyScale;\r\n\r\n\t};\r\n\r\n\tthis.update = function () {\r\n        \r\n        if(scope.object.top !== undefined) {\r\n            this.object.top = (scale*this.object.top);\r\n            this.object.bottom = (scale*this.object.bottom);\r\n            this.object.left = (scale*this.object.left);\r\n            this.object.right = (scale*this.object.right);\r\n            \r\n            this.object.updateProjectionMatrix();\r\n\r\n        }\r\n            \r\n\r\n\t\tvar position = this.object.position;\r\n\r\n\t\toffset.copy( position ).sub( this.target );\r\n//\r\n//\t\t// angle from z-axis around y-axis\r\n//\r\n//\t\tvar theta = Math.atan2( offset.x, offset.z );\r\n//\r\n//\t\t// angle from y-axis\r\n//\r\n//\t\tvar phi = Math.atan2( Math.sqrt( offset.x * offset.x + offset.z * offset.z ), offset.y );\r\n//\r\n//\t\tif ( this.autoRotate ) {\r\n//\r\n//\t\t\tthis.rotateLeft( getAutoRotationAngle() );\r\n//\r\n//\t\t}\r\n//\r\n//\t\ttheta += thetaDelta;\r\n//\t\tphi += phiDelta;\r\n//\r\n//\t\t// restrict phi to be between desired limits\r\n//\t\tphi = Math.max( this.minPolarAngle, Math.min( this.maxPolarAngle, phi ) );\r\n//\r\n//\t\t// restrict phi to be betwee EPS and PI-EPS\r\n//\t\tphi = Math.max( EPS, Math.min( Math.PI - EPS, phi ) );\r\n//\r\n//\t\tvar radius = offset.length() * scale;\r\n//\r\n//\t\t// restrict radius to be between desired limits\r\n//\t\tradius = Math.max( this.minDistance, Math.min( this.maxDistance, radius ) );\r\n//\t\t\r\n//\t\t// move target to panned location\r\n\t\tthis.target.add( pan );\r\n//\t\t\r\n//\t\toffset.x = radius * Math.sin( phi ) * Math.sin( theta );\r\n//\t\toffset.y = radius * Math.cos( phi );\r\n//\t\toffset.z = radius * Math.sin( phi ) * Math.cos( theta );\r\n//\r\n\t\tposition.copy( this.target ).add( offset );\r\n\r\n\t\tthis.object.lookAt( this.target );\r\n\r\n\r\n//\t\tif ( lastPosition.distanceTo( this.object.position ) > 0 || scale !== 1 ) {\r\n\r\n\t\t\tthis.dispatchEvent( changeEvent );\r\n\r\n//\t\t\tlastPosition.copy( this.object.position );\r\n\r\n//\t\t}\r\n        \r\n//        thetaDelta = 0;\r\n//\t\tphiDelta = 0;\r\n\t\tscale = 1;\r\n\t\tpan.set( 0, 0, 0 );\r\n\r\n\t};\r\n\r\n\r\n\tthis.reset = function () {\r\n\r\n\t\tstate = STATE.NONE;\r\n\r\n\t\tthis.target.copy( this.target0 );\r\n\t\tthis.object.position.copy( this.position0 );\r\n\r\n\t\tthis.update();\r\n\r\n\t};\r\n\r\n\tfunction getAutoRotationAngle() {\r\n\r\n\t\treturn 2 * Math.PI / 60 / 60 * scope.autoRotateSpeed;\r\n\r\n\t}\r\n\r\n\tfunction getZoomScale() {\r\n\r\n\t\treturn Math.pow( 0.95, scope.zoomSpeed );\r\n\r\n\t}\r\n\r\n\tfunction onMouseDown( event ) {\r\n\r\n\t\tif ( scope.enabled === false ) return;\r\n\t\tevent.preventDefault();\r\n\r\n\t\tif ( event.button === 0 ) {\r\n\t\t\tif ( scope.noRotate === true ) return;\r\n\r\n\t\t\tstate = STATE.ROTATE;\r\n\r\n\t\t\trotateStart.set( event.clientX, event.clientY );\r\n\r\n\t\t} else if ( event.button === 1 ) {\r\n\t\t\tif ( scope.noZoom === true ) return;\r\n\r\n\t\t\tstate = STATE.DOLLY;\r\n\r\n\t\t\tdollyStart.set( event.clientX, event.clientY );\r\n\r\n\t\t} else if ( event.button === 2 ) {\r\n\t\t\tif ( scope.noPan === true ) return;\r\n\r\n\t\t\tstate = STATE.PAN;\r\n\r\n\t\t\tpanStart.set( event.clientX, event.clientY );\r\n\r\n\t\t}\r\n\r\n\t\tscope.domElement.addEventListener( 'mousemove', onMouseMove, false );\r\n\t\tscope.domElement.addEventListener( 'mouseup', onMouseUp, false );\r\n\t\tscope.dispatchEvent( startEvent );\r\n\r\n\t}\r\n\r\n\tfunction onMouseMove( event ) {\r\n\r\n\t\tif ( scope.enabled === false ) return;\r\n\r\n\t\tevent.preventDefault();\r\n\r\n\t\tvar element = scope.domElement === document ? scope.domElement.body : scope.domElement;\r\n\r\n\t\tif ( state === STATE.ROTATE ) {\r\n\r\n\t\t\tif ( scope.noRotate === true ) return;\r\n\r\n\t\t\trotateEnd.set( event.clientX, event.clientY );\r\n\t\t\trotateDelta.subVectors( rotateEnd, rotateStart );\r\n\r\n\t\t\t// rotating across whole screen goes 360 degrees around\r\n\t\t\tscope.rotateLeft( 2 * Math.PI * rotateDelta.x / element.clientWidth * scope.rotateSpeed );\r\n\r\n\t\t\t// rotating up and down along whole screen attempts to go 360, but limited to 180\r\n\t\t\tscope.rotateUp( 2 * Math.PI * rotateDelta.y / element.clientHeight * scope.rotateSpeed );\r\n\r\n\t\t\trotateStart.copy( rotateEnd );\r\n\r\n\t\t} else if ( state === STATE.DOLLY ) {\r\n\r\n\t\t\tif ( scope.noZoom === true ) return;\r\n\r\n\t\t\tdollyEnd.set( event.clientX, event.clientY );\r\n\t\t\tdollyDelta.subVectors( dollyEnd, dollyStart );\r\n\r\n\t\t\tif ( dollyDelta.y > 0 ) {\r\n\r\n\t\t\t\tscope.dollyIn();\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tscope.dollyOut();\r\n\r\n\t\t\t}\r\n\r\n\t\t\tdollyStart.copy( dollyEnd );\r\n\r\n\t\t} else if ( state === STATE.PAN ) {\r\n\r\n\t\t\tif ( scope.noPan === true ) return;\r\n\r\n\t\t\tpanEnd.set( event.clientX, event.clientY );\r\n\t\t\tpanDelta.subVectors( panEnd, panStart );\r\n\t\t\t\r\n\t\t\tscope.pan( panDelta.x, panDelta.y );\r\n\r\n\t\t\tpanStart.copy( panEnd );\r\n\r\n\t\t}\r\n\r\n\t\tscope.update();\r\n\r\n\t}\r\n\r\n\tfunction onMouseUp( /* event */ ) {\r\n\r\n\t\tif ( scope.enabled === false ) return;\r\n\r\n\t\tscope.domElement.removeEventListener( 'mousemove', onMouseMove, false );\r\n\t\tscope.domElement.removeEventListener( 'mouseup', onMouseUp, false );\r\n\t\tscope.dispatchEvent( endEvent );\r\n\t\tstate = STATE.NONE;\r\n\r\n\t}\r\n\r\n\tfunction onMouseWheel( event ) {\r\n\r\n\t\tif ( scope.enabled === false || scope.noZoom === true ) return;\r\n\r\n\t\tevent.preventDefault();\r\n\r\n\t\tvar delta = 0;\r\n\r\n\t\tif ( event.wheelDelta !== undefined ) { // WebKit / Opera / Explorer 9\r\n\r\n\t\t\tdelta = event.wheelDelta;\r\n\r\n\t\t} else if ( event.detail !== undefined ) { // Firefox\r\n\r\n\t\t\tdelta = - event.detail;\r\n\r\n\t\t}\r\n\r\n\t\tif ( delta > 0 ) {\r\n\r\n\t\t\tscope.dollyOut();\r\n\r\n\t\t} else {\r\n\r\n\t\t\tscope.dollyIn();\r\n\r\n\t\t}\r\n\r\n\t\tscope.update();\r\n\t\tscope.dispatchEvent( startEvent );\r\n\t\tscope.dispatchEvent( endEvent );\r\n\r\n\t}\r\n\r\n\tfunction onKeyDown( event ) {\r\n\r\n\t\tif ( scope.enabled === false || scope.noKeys === true || scope.noPan === true ) return;\r\n\t\t\r\n\t\tswitch ( event.keyCode ) {\r\n\r\n\t\t\tcase scope.keys.UP:\r\n\t\t\t\tscope.pan( 0, scope.keyPanSpeed );\r\n\t\t\t\tscope.update();\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase scope.keys.BOTTOM:\r\n\t\t\t\tscope.pan( 0, - scope.keyPanSpeed );\r\n\t\t\t\tscope.update();\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase scope.keys.LEFT:\r\n\t\t\t\tscope.pan( scope.keyPanSpeed, 0 );\r\n\t\t\t\tscope.update();\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase scope.keys.RIGHT:\r\n\t\t\t\tscope.pan( - scope.keyPanSpeed, 0 );\r\n\t\t\t\tscope.update();\r\n\t\t\t\tbreak;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction touchstart( event ) {\r\n\r\n\t\tif ( scope.enabled === false ) return;\r\n\r\n\t\tswitch ( event.touches.length ) {\r\n\r\n\t\t\tcase 1:\t// one-fingered touch: rotate\r\n\r\n\t\t\t\tif ( scope.noRotate === true ) return;\r\n\r\n\t\t\t\tstate = STATE.TOUCH_ROTATE;\r\n\r\n\t\t\t\trotateStart.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase 2:\t// two-fingered touch: dolly\r\n\r\n\t\t\t\tif ( scope.noZoom === true ) return;\r\n\r\n\t\t\t\tstate = STATE.TOUCH_DOLLY;\r\n\r\n\t\t\t\tvar dx = event.touches[ 0 ].pageX - event.touches[ 1 ].pageX;\r\n\t\t\t\tvar dy = event.touches[ 0 ].pageY - event.touches[ 1 ].pageY;\r\n\t\t\t\tvar distance = Math.sqrt( dx * dx + dy * dy );\r\n\t\t\t\tdollyStart.set( 0, distance );\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase 3: // three-fingered touch: pan\r\n\r\n\t\t\t\tif ( scope.noPan === true ) return;\r\n\r\n\t\t\t\tstate = STATE.TOUCH_PAN;\r\n\r\n\t\t\t\tpanStart.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tdefault:\r\n\r\n\t\t\t\tstate = STATE.NONE;\r\n\r\n\t\t}\r\n\r\n\t\tscope.dispatchEvent( startEvent );\r\n\r\n\t}\r\n\r\n\tfunction touchmove( event ) {\r\n\r\n\t\tif ( scope.enabled === false ) return;\r\n\r\n\t\tevent.preventDefault();\r\n\t\tevent.stopPropagation();\r\n\r\n\t\tvar element = scope.domElement === document ? scope.domElement.body : scope.domElement;\r\n\r\n\t\tswitch ( event.touches.length ) {\r\n\r\n\t\t\tcase 1: // one-fingered touch: rotate\r\n\r\n\t\t\t\tif ( scope.noRotate === true ) return;\r\n\t\t\t\tif ( state !== STATE.TOUCH_ROTATE ) return;\r\n\r\n\t\t\t\trotateEnd.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );\r\n\t\t\t\trotateDelta.subVectors( rotateEnd, rotateStart );\r\n\r\n\t\t\t\t// rotating across whole screen goes 360 degrees around\r\n\t\t\t\tscope.rotateLeft( 2 * Math.PI * rotateDelta.x / element.clientWidth * scope.rotateSpeed );\r\n\t\t\t\t// rotating up and down along whole screen attempts to go 360, but limited to 180\r\n\t\t\t\tscope.rotateUp( 2 * Math.PI * rotateDelta.y / element.clientHeight * scope.rotateSpeed );\r\n\r\n\t\t\t\trotateStart.copy( rotateEnd );\r\n\r\n\t\t\t\tscope.update();\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase 2: // two-fingered touch: dolly\r\n\r\n\t\t\t\tif ( scope.noZoom === true ) return;\r\n\t\t\t\tif ( state !== STATE.TOUCH_DOLLY ) return;\r\n\r\n\t\t\t\tvar dx = event.touches[ 0 ].pageX - event.touches[ 1 ].pageX;\r\n\t\t\t\tvar dy = event.touches[ 0 ].pageY - event.touches[ 1 ].pageY;\r\n\t\t\t\tvar distance = Math.sqrt( dx * dx + dy * dy );\r\n\r\n\t\t\t\tdollyEnd.set( 0, distance );\r\n\t\t\t\tdollyDelta.subVectors( dollyEnd, dollyStart );\r\n\r\n\t\t\t\tif ( dollyDelta.y > 0 ) {\r\n\r\n\t\t\t\t\tscope.dollyOut();\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tscope.dollyIn();\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tdollyStart.copy( dollyEnd );\r\n\r\n\t\t\t\tscope.update();\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase 3: // three-fingered touch: pan\r\n\r\n\t\t\t\tif ( scope.noPan === true ) return;\r\n\t\t\t\tif ( state !== STATE.TOUCH_PAN ) return;\r\n\r\n\t\t\t\tpanEnd.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );\r\n\t\t\t\tpanDelta.subVectors( panEnd, panStart );\r\n\t\t\t\t\r\n\t\t\t\tscope.pan( panDelta.x, panDelta.y );\r\n\r\n\t\t\t\tpanStart.copy( panEnd );\r\n\r\n\t\t\t\tscope.update();\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tdefault:\r\n\r\n\t\t\t\tstate = STATE.NONE;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction touchend( /* event */ ) {\r\n\r\n\t\tif ( scope.enabled === false ) return;\r\n\r\n\t\tscope.dispatchEvent( endEvent );\r\n\t\tstate = STATE.NONE;\r\n\r\n\t}\r\n\r\n\tthis.domElement.addEventListener( 'contextmenu', function ( event ) { event.preventDefault(); }, false );\r\n\tthis.domElement.addEventListener( 'mousedown', onMouseDown, false );\r\n\tthis.domElement.addEventListener( 'mousewheel', onMouseWheel, false );\r\n\tthis.domElement.addEventListener( 'DOMMouseScroll', onMouseWheel, false ); // firefox\r\n\r\n\tthis.domElement.addEventListener( 'touchstart', touchstart, false );\r\n\tthis.domElement.addEventListener( 'touchend', touchend, false );\r\n\tthis.domElement.addEventListener( 'touchmove', touchmove, false );\r\n\r\n\twindow.addEventListener( 'keydown', onKeyDown, false );\r\n\r\n};\r\n\r\nOrbitControls.prototype = Object.create( external_THREE_[\"EventDispatcher\"].prototype );\n// CONCATENATED MODULE: ./src/index.js\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Viewer\", function() { return Viewer; });\n\r\n\r\n\r\n// Three.js extension functions. Webpack doesn't seem to like it if we modify the THREE object directly.\r\nvar THREEx = { Math: {} };\r\n/**\r\n * Returns the angle in radians of the vector (p1,p2). In other words, imagine\r\n * putting the base of the vector at coordinates (0,0) and finding the angle\r\n * from vector (1,0) to (p1,p2).\r\n * @param  {Object} p1 start point of the vector\r\n * @param  {Object} p2 end point of the vector\r\n * @return {Number} the angle\r\n */\r\nTHREEx.Math.angle2 = function(p1, p2) {\r\n\tvar v1 = new external_THREE_[\"Vector2\"](p1.x, p1.y);\r\n\tvar v2 = new external_THREE_[\"Vector2\"](p2.x, p2.y);\r\n\tv2.sub(v1); // sets v2 to be our chord\r\n\tv2.normalize();\r\n\tif(v2.y < 0) return -Math.acos(v2.x);\r\n\treturn Math.acos(v2.x);\r\n};\r\n\r\n\r\nTHREEx.Math.polar = function(point, distance, angle) {\r\n\tvar result = {};\r\n\tresult.x = point.x + distance * Math.cos(angle);\r\n\tresult.y = point.y + distance * Math.sin(angle);\r\n\treturn result;\r\n};\r\n\r\n/**\r\n * Calculates points for a curve between two points\r\n * @param startPoint - the starting point of the curve\r\n * @param endPoint - the ending point of the curve\r\n * @param bulge - a value indicating how much to curve\r\n * @param segments - number of segments between the two given points\r\n */\r\nTHREEx.BulgeGeometry = function ( startPoint, endPoint, bulge, segments ) {\r\n\r\n\tvar vertex, i,\r\n\t\tcenter, p0, p1, angle,\r\n\t\tradius, startAngle,\r\n\t\tthetaAngle;\r\n\r\n\texternal_THREE_[\"Geometry\"].call( this );\r\n\r\n\tthis.startPoint = p0 = startPoint ? new external_THREE_[\"Vector2\"](startPoint.x, startPoint.y) : new external_THREE_[\"Vector2\"](0,0);\r\n\tthis.endPoint = p1 = endPoint ? new external_THREE_[\"Vector2\"](endPoint.x, endPoint.y) : new external_THREE_[\"Vector2\"](1,0);\r\n\tthis.bulge = bulge = bulge || 1;\r\n\r\n\tangle = 4 * Math.atan(bulge);\r\n\tradius = p0.distanceTo(p1) / 2 / Math.sin(angle/2);\r\n\tcenter = THREEx.Math.polar(startPoint, radius, THREEx.Math.angle2(p0,p1) + (Math.PI / 2 - angle/2));\r\n\r\n\tthis.segments = segments = segments || Math.max( Math.abs(Math.ceil(angle/(Math.PI/18))), 6); // By default want a segment roughly every 10 degrees\r\n\tstartAngle = THREEx.Math.angle2(center, p0);\r\n\tthetaAngle = angle / segments;\r\n\r\n\r\n\tthis.vertices.push(new external_THREE_[\"Vector3\"](p0.x, p0.y, 0));\r\n\r\n\tfor(i = 1; i <= segments - 1; i++) {\r\n\r\n\t\tvertex = THREEx.Math.polar(center, Math.abs(radius), startAngle + thetaAngle * i);\r\n\r\n\t\tthis.vertices.push(new external_THREE_[\"Vector3\"](vertex.x, vertex.y, 0));\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREEx.BulgeGeometry.prototype = Object.create( external_THREE_[\"Geometry\"].prototype );\r\n    \r\n/**\r\n * Viewer class for a dxf object.\r\n * @param {Object} data - the dxf object\r\n * @param {Object} parent - the parent element to which we attach the rendering canvas\r\n * @param {Number} width - width of the rendering canvas in pixels\r\n * @param {Number} height - height of the rendering canvas in pixels\r\n * @param {Object} font - a font loaded with THREE.FontLoader \r\n * @constructor\r\n */\r\nfunction Viewer(data, parent, width, height, font) {\r\n\r\n    createLineTypeShaders(data);\r\n\r\n    var scene = new external_THREE_[\"Scene\"]();\r\n\r\n    // Create scene from dxf object (data)\r\n    var i, entity, obj, min_x, min_y, min_z, max_x, max_y, max_z;\r\n    var dims = {\r\n        min: { x: false, y: false, z: false},\r\n        max: { x: false, y: false, z: false}\r\n    };\r\n    for(i = 0; i < data.entities.length; i++) {\r\n        entity = data.entities[i];\r\n\r\n        if(entity.type === 'DIMENSION') {\r\n            if(entity.block) {\r\n                var block = data.blocks[entity.block];\r\n                if(!block) {\r\n                    console.error('Missing referenced block \"' + entity.block + '\"');\r\n                    continue;\r\n                }\r\n                for(var j = 0; j < block.entities.length; j++) {\r\n                    obj = drawEntity(block.entities[j], data);\r\n                }\r\n            } else {\r\n                console.log('WARNING: No block for DIMENSION entity');\r\n            }\r\n        } else {\r\n            obj = drawEntity(entity, data);\r\n        }\r\n\r\n        if (obj) {\r\n            var bbox = new external_THREE_[\"Box3\"]().setFromObject(obj);\r\n            if (bbox.min.x && ((dims.min.x === false) || (dims.min.x > bbox.min.x))) dims.min.x = bbox.min.x;\r\n            if (bbox.min.y && ((dims.min.y === false) || (dims.min.y > bbox.min.y))) dims.min.y = bbox.min.y;\r\n            if (bbox.min.z && ((dims.min.z === false) || (dims.min.z > bbox.min.z))) dims.min.z = bbox.min.z;\r\n            if (bbox.max.x && ((dims.max.x === false) || (dims.max.x < bbox.max.x))) dims.max.x = bbox.max.x;\r\n            if (bbox.max.y && ((dims.max.y === false) || (dims.max.y < bbox.max.y))) dims.max.y = bbox.max.y;\r\n            if (bbox.max.z && ((dims.max.z === false) || (dims.max.z < bbox.max.z))) dims.max.z = bbox.max.z;\r\n            scene.add(obj);\r\n        }\r\n        obj = null;\r\n    }\r\n\r\n    width = width || parent.innerWidth;\r\n    height = height || parent.innerHeight;\r\n    var aspectRatio = width / height;\r\n\r\n    var upperRightCorner = { x: dims.max.x, y: dims.max.y };\r\n    var lowerLeftCorner = { x: dims.min.x, y: dims.min.y };\r\n\r\n    // Figure out the current viewport extents\r\n    var vp_width = upperRightCorner.x - lowerLeftCorner.x;\r\n    var vp_height = upperRightCorner.y - lowerLeftCorner.y;\r\n    var center = center || {\r\n        x: vp_width / 2 + lowerLeftCorner.x,\r\n        y: vp_height / 2 + lowerLeftCorner.y\r\n    };\r\n\r\n    // Fit all objects into current ThreeDXF viewer\r\n    var extentsAspectRatio = Math.abs(vp_width / vp_height);\r\n    if (aspectRatio > extentsAspectRatio) {\r\n        vp_width = vp_height * aspectRatio;\r\n    } else {\r\n        vp_height = vp_width / aspectRatio;\r\n    }\r\n    \r\n    var viewPort = {\r\n        bottom: -vp_height / 2,\r\n        left: -vp_width / 2,\r\n        top: vp_height / 2,\r\n        right: vp_width / 2,\r\n        center: {\r\n            x: center.x,\r\n            y: center.y\r\n        }\r\n    };\r\n\r\n    var camera = new external_THREE_[\"OrthographicCamera\"](viewPort.left, viewPort.right, viewPort.top, viewPort.bottom, 1, 19);\r\n    camera.position.z = 10;\r\n    camera.position.x = viewPort.center.x;\r\n    camera.position.y = viewPort.center.y;\r\n\r\n    var renderer = this.renderer = new external_THREE_[\"WebGLRenderer\"]();\r\n    renderer.setSize(width, height);\r\n    renderer.setClearColor(0xfffffff, 1);\r\n\r\n    parent.appendChild(renderer.domElement);\r\n    parent.style.display = 'block';\r\n\r\n    //TODO: Need to make this an option somehow so others can roll their own controls.\r\n    var controls = new OrbitControls(camera, parent);\r\n    controls.target.x = camera.position.x;\r\n    controls.target.y = camera.position.y;\r\n    controls.target.z = 0;\r\n    controls.zoomSpeed = 3;\r\n\r\n    //Uncomment this to disable rotation (does not make much sense with 2D drawings).\r\n    //controls.enableRotate = false;\r\n\r\n    this.render = function() { renderer.render(scene, camera) };\r\n    controls.addEventListener('change', this.render);\r\n    this.render();\r\n    controls.update();\r\n\r\n    this.resize = function(width, height) {\r\n        var originalWidth = renderer.domElement.width;\r\n        var originalHeight = renderer.domElement.height;\r\n\r\n        var hscale = width / originalWidth;\r\n        var vscale = height / originalHeight;\r\n\r\n\r\n        camera.top = (vscale * camera.top);\r\n        camera.bottom = (vscale * camera.bottom);\r\n        camera.left = (hscale * camera.left);\r\n        camera.right = (hscale * camera.right);\r\n\r\n//        camera.updateProjectionMatrix();\r\n\r\n        renderer.setSize(width, height);\r\n        renderer.setClearColor(0xfffffff, 1);\r\n        this.render();\r\n    };\r\n\r\n    function drawEntity(entity, data) {\r\n        var mesh;\r\n        if(entity.type === 'CIRCLE' || entity.type === 'ARC') {\r\n            mesh = drawArc(entity, data);\r\n        } else if(entity.type === 'LWPOLYLINE' || entity.type === 'LINE' || entity.type === 'POLYLINE') {\r\n            mesh = drawLine(entity, data);\r\n        } else if(entity.type === 'TEXT') {\r\n            mesh = drawText(entity, data);\r\n        } else if(entity.type === 'SOLID') {\r\n            mesh = drawSolid(entity, data);\r\n        } else if(entity.type === 'POINT') {\r\n            mesh = drawPoint(entity, data);\r\n        } else if(entity.type === 'INSERT') {\r\n            mesh = drawBlock(entity, data);\r\n        } else if(entity.type === 'SPLINE') {\r\n            mesh = drawSpline(entity, data);\r\n        } else if(entity.type === 'MTEXT') {\r\n            mesh = drawMtext(entity, data);\r\n        } else if(entity.type === 'ELLIPSE') {\r\n            mesh = drawEllipse(entity, data);\r\n        }\r\n        else {\r\n            console.log(\"Unsupported Entity Type: \" + entity.type);\r\n        }\r\n        return mesh;\r\n    }\r\n\r\n    function drawEllipse(entity, data) {\r\n        var color = getColor(entity, data);\r\n\r\n        var xrad = Math.sqrt(Math.pow(entity.majorAxisEndPoint.x,2) + Math.pow(entity.majorAxisEndPoint.y,2));\r\n        var yrad = xrad*entity.axisRatio;\r\n        var rotation = Math.atan2(entity.majorAxisEndPoint.y, entity.majorAxisEndPoint.x);\r\n\r\n        var curve = new external_THREE_[\"EllipseCurve\"](\r\n            entity.center.x,  entity.center.y,\r\n            xrad, yrad,\r\n            entity.startAngle, entity.endAngle,\r\n            false, // Always counterclockwise\r\n            rotation\r\n        );\r\n\r\n        var points = curve.getPoints( 50 );\r\n        var geometry = new external_THREE_[\"BufferGeometry\"]().setFromPoints( points );\r\n        var material = new external_THREE_[\"LineBasicMaterial\"]( {  linewidth: 1, color : color } );\r\n\r\n        // Create the final object to add to the scene\r\n        var ellipse = new external_THREE_[\"Line\"]( geometry, material );\r\n        return ellipse;\r\n    }\r\n\r\n    function drawMtext(entity, data) {\r\n        var color = getColor(entity, data);\r\n\r\n        var geometry = new external_THREE_[\"TextGeometry\"]( entity.text, {\r\n            font: font,\r\n            size: entity.height * (4/5),\r\n            height: 1\r\n        });\r\n        var material = new external_THREE_[\"MeshBasicMaterial\"]( {color: color} );\r\n        var text = new external_THREE_[\"Mesh\"]( geometry, material );\r\n\r\n        // Measure what we rendered.\r\n        var measure = new external_THREE_[\"Box3\"]();\r\n        measure.setFromObject( text );\r\n\r\n        var textWidth  = measure.max.x - measure.min.x;\r\n\r\n        // If the text ends up being wider than the box, it's supposed\r\n        // to be multiline. Doing that in threeJS is overkill.\r\n        if (textWidth > entity.width) {\r\n            console.log(\"Can't render this multipline MTEXT entity, sorry.\", entity);\r\n            return undefined;\r\n        }\r\n\r\n        text.position.z = 0;\r\n        switch (entity.attachmentPoint) {\r\n            case 1:\r\n                // Top Left\r\n                text.position.x = entity.position.x;\r\n                text.position.y = entity.position.y - entity.height;\r\n            break;\r\n            case 2:\r\n                // Top Center\r\n                text.position.x = entity.position.x - textWidth/2;\r\n                text.position.y = entity.position.y - entity.height;\r\n            break;\r\n            case 3:\r\n                // Top Right\r\n                text.position.x = entity.position.x - textWidth;\r\n                text.position.y = entity.position.y - entity.height;\r\n            break;\r\n\r\n            case 4:\r\n                // Middle Left\r\n                text.position.x = entity.position.x;\r\n                text.position.y = entity.position.y - entity.height/2;\r\n            break;\r\n            case 5:\r\n                // Middle Center\r\n                text.position.x = entity.position.x - textWidth/2;\r\n                text.position.y = entity.position.y - entity.height/2;\r\n            break;\r\n            case 6:\r\n                // Middle Right\r\n                text.position.x = entity.position.x - textWidth;\r\n                text.position.y = entity.position.y - entity.height/2;\r\n            break;\r\n\r\n            case 7:\r\n                // Bottom Left\r\n                text.position.x = entity.position.x;\r\n                text.position.y = entity.position.y;\r\n            break;\r\n            case 8:\r\n                // Bottom Center\r\n                text.position.x = entity.position.x - textWidth/2;\r\n                text.position.y = entity.position.y;\r\n            break;\r\n            case 9:\r\n                // Bottom Right\r\n                text.position.x = entity.position.x - textWidth;\r\n                text.position.y = entity.position.y;\r\n            break;\r\n\r\n            default:\r\n                return undefined;\r\n        };\r\n\r\n        return text;\r\n    }\r\n\r\n    function drawSpline(entity, data) {\r\n        var color = getColor(entity, data);\r\n\r\n        var points = entity.controlPoints.map(function(vec) {\r\n            return new external_THREE_[\"Vector2\"](vec.x, vec.y);\r\n        });\r\n\r\n        var interpolatedPoints = [];\r\n        if (entity.degreeOfSplineCurve === 2 || entity.degreeOfSplineCurve === 3) {\r\n            for(var i = 0; i + 2 < points.length; i = i + 2) {\r\n        if (entity.degreeOfSplineCurve === 2) {\r\n                        curve = new external_THREE_[\"QuadraticBezierCurve\"](points[i], points[i + 1], points[i + 2]);\r\n        } else {\r\n            curve = new external_THREE_[\"QuadraticBezierCurve3\"](points[i], points[i + 1], points[i + 2]);\r\n        }\r\n                interpolatedPoints.push.apply(interpolatedPoints, curve.getPoints(50));\r\n            }\r\n        } else {\r\n            curve = new external_THREE_[\"SplineCurve\"](points);\r\n            interpolatedPoints = curve.getPoints( 100 );\r\n        }\r\n\r\n        var geometry = new external_THREE_[\"BufferGeometry\"]().setFromPoints( interpolatedPoints );\r\n        var material = new external_THREE_[\"LineBasicMaterial\"]( { linewidth: 1, color : color } );\r\n        var splineObject = new external_THREE_[\"Line\"]( geometry, material );\r\n\r\n        return splineObject;\r\n    }\r\n\r\n    function drawLine(entity, data) {\r\n        var geometry = new external_THREE_[\"Geometry\"](),\r\n            color = getColor(entity, data),\r\n            material, lineType, vertex, startPoint, endPoint, bulgeGeometry,\r\n            bulge, i, line;\r\n\r\n        // create geometry\r\n        for(i = 0; i < entity.vertices.length; i++) {\r\n\r\n            if(entity.vertices[i].bulge) {\r\n                bulge = entity.vertices[i].bulge;\r\n                startPoint = entity.vertices[i];\r\n                endPoint = i + 1 < entity.vertices.length ? entity.vertices[i + 1] : geometry.vertices[0];\r\n\r\n                bulgeGeometry = new THREEx.BulgeGeometry(startPoint, endPoint, bulge);\r\n\r\n                geometry.vertices.push.apply(geometry.vertices, bulgeGeometry.vertices);\r\n            } else {\r\n                vertex = entity.vertices[i];\r\n                geometry.vertices.push(new external_THREE_[\"Vector3\"](vertex.x, vertex.y, 0));\r\n            }\r\n\r\n        }\r\n        if(entity.shape) geometry.vertices.push(geometry.vertices[0]);\r\n\r\n\r\n        // set material\r\n        if(entity.lineType) {\r\n            lineType = data.tables.lineType.lineTypes[entity.lineType];\r\n        }\r\n\r\n        if(lineType && lineType.pattern && lineType.pattern.length !== 0) {\r\n            material = new external_THREE_[\"LineDashedMaterial\"]({ color: color, gapSize: 4, dashSize: 4});\r\n        } else {\r\n            material = new external_THREE_[\"LineBasicMaterial\"]({ linewidth: 1, color: color });\r\n        }\r\n\r\n        // if(lineType && lineType.pattern && lineType.pattern.length !== 0) {\r\n\r\n        //           geometry.computeLineDistances();\r\n\r\n        //           // Ugly hack to add diffuse to this. Maybe copy the uniforms object so we\r\n        //           // don't add diffuse to a material.\r\n        //           lineType.material.uniforms.diffuse = { type: 'c', value: new THREE.Color(color) };\r\n\r\n        // \tmaterial = new THREE.ShaderMaterial({\r\n        // \t\tuniforms: lineType.material.uniforms,\r\n        // \t\tvertexShader: lineType.material.vertexShader,\r\n        // \t\tfragmentShader: lineType.material.fragmentShader\r\n        // \t});\r\n        // }else {\r\n        // \tmaterial = new THREE.LineBasicMaterial({ linewidth: 1, color: color });\r\n        // }\r\n\r\n        line = new external_THREE_[\"Line\"](geometry, material);\r\n        return line;\r\n    }\r\n    \r\n    function drawArc(entity, data) {\r\n        if (entity.type === 'CIRCLE') {\r\n            startAngle = entity.startAngle || 0;\r\n            endAngle = startAngle + 2 * Math.PI;\r\n        } else {\r\n            startAngle = entity.startAngle;\r\n            endAngle = entity.endAngle;\r\n        }\r\n\r\n        var curve = new external_THREE_[\"ArcCurve\"](\r\n            0, 0,\r\n            entity.radius,\r\n            startAngle,\r\n            endAngle);\r\n\r\n        var points = curve.getPoints( 32 );\r\n        var geometry = new external_THREE_[\"BufferGeometry\"]().setFromPoints( points );\r\n\r\n        var material = new external_THREE_[\"LineBasicMaterial\"]({ color: getColor(entity, data) });\r\n\r\n        var arc = new external_THREE_[\"Line\"](geometry, material);\r\n        arc.position.x = entity.center.x;\r\n        arc.position.y = entity.center.y;\r\n        arc.position.z = entity.center.z;\r\n\r\n        return arc;\r\n    }\r\n\r\n    function drawSolid(entity, data) {\r\n        var material, mesh, verts,\r\n            geometry = new external_THREE_[\"Geometry\"]();\r\n\r\n        verts = geometry.vertices;\r\n        verts.push(new external_THREE_[\"Vector3\"](entity.points[0].x, entity.points[0].y, entity.points[0].z));\r\n        verts.push(new external_THREE_[\"Vector3\"](entity.points[1].x, entity.points[1].y, entity.points[1].z));\r\n        verts.push(new external_THREE_[\"Vector3\"](entity.points[2].x, entity.points[2].y, entity.points[2].z));\r\n        verts.push(new external_THREE_[\"Vector3\"](entity.points[3].x, entity.points[3].y, entity.points[3].z));\r\n\r\n        // Calculate which direction the points are facing (clockwise or counter-clockwise)\r\n        var vector1 = new external_THREE_[\"Vector3\"]();\r\n        var vector2 = new external_THREE_[\"Vector3\"]();\r\n        vector1.subVectors(verts[1], verts[0]);\r\n        vector2.subVectors(verts[2], verts[0]);\r\n        vector1.cross(vector2);\r\n\r\n        // If z < 0 then we must draw these in reverse order\r\n        if(vector1.z < 0) {\r\n            geometry.faces.push(new external_THREE_[\"Face3\"](2, 1, 0));\r\n            geometry.faces.push(new external_THREE_[\"Face3\"](2, 3, 1));\r\n        } else {\r\n            geometry.faces.push(new external_THREE_[\"Face3\"](0, 1, 2));\r\n            geometry.faces.push(new external_THREE_[\"Face3\"](1, 3, 2));\r\n        }\r\n\r\n\r\n        material = new external_THREE_[\"MeshBasicMaterial\"]({ color: getColor(entity, data) });\r\n\r\n        return new external_THREE_[\"Mesh\"](geometry, material);\r\n        \r\n    }\r\n\r\n    function drawText(entity, data) {\r\n        var geometry, material, text;\r\n\r\n        if(!font)\r\n            return console.warn('Text is not supported without a Three.js font loaded with THREE.FontLoader! Load a font of your choice and pass this into the constructor. See the sample for this repository or Three.js examples at http://threejs.org/examples/?q=text#webgl_geometry_text for more details.');\r\n        \r\n        geometry = new external_THREE_[\"TextGeometry\"](entity.text, { font: font, height: 0, size: entity.textHeight || 12 });\r\n\r\n        material = new external_THREE_[\"MeshBasicMaterial\"]({ color: getColor(entity, data) });\r\n\r\n        text = new external_THREE_[\"Mesh\"](geometry, material);\r\n        text.position.x = entity.startPoint.x;\r\n        text.position.y = entity.startPoint.y;\r\n        text.position.z = entity.startPoint.z;\r\n\r\n        return text;\r\n    }\r\n\r\n    function drawPoint(entity, data) {\r\n        var geometry, material, point;\r\n\r\n        geometry = new external_THREE_[\"Geometry\"]();\r\n\r\n        geometry.vertices.push(new external_THREE_[\"Vector3\"](entity.position.x, entity.position.y, entity.position.z));\r\n\r\n        // TODO: could be more efficient. PointCloud per layer?\r\n\r\n        var numPoints = 1;\r\n\r\n        var color = getColor(entity, data);\r\n        var colors = new Float32Array( numPoints*3 );\r\n        colors[0] = color.r;\r\n        colors[1] = color.g;\r\n        colors[2] = color.b;\r\n\r\n        geometry.colors = colors;\r\n        geometry.computeBoundingBox();\r\n\r\n        material = new external_THREE_[\"PointsMaterial\"]( { size: 0.05, vertexColors: external_THREE_[\"VertexColors\"] } );\r\n        point = new external_THREE_[\"Points\"](geometry, material);\r\n        scene.add(point);\r\n    }\r\n\r\n    function drawBlock(entity, data) {\r\n        var block = data.blocks[entity.name];\r\n        \r\n        if (!block.entities) return null;\r\n\r\n        var group = new external_THREE_[\"Object3D\"]()\r\n        \r\n        if(entity.xScale) group.scale.x = entity.xScale;\r\n        if(entity.yScale) group.scale.y = entity.yScale;\r\n\r\n        if(entity.rotation) {\r\n            group.rotation.z = entity.rotation * Math.PI / 180;\r\n        }\r\n\r\n        if(entity.position) {\r\n            group.position.x = entity.position.x;\r\n            group.position.y = entity.position.y;\r\n            group.position.z = entity.position.z;\r\n        }\r\n        \r\n        for(var i = 0; i < block.entities.length; i++) {\r\n            var childEntity = drawEntity(block.entities[i], data, group);\r\n            if(childEntity) group.add(childEntity);\r\n        }\r\n\r\n        return group;\r\n    }\r\n\r\n    function getColor(entity, data) {\r\n        var color = 0x000000; //default\r\n        if(entity.color) color = entity.color;\r\n        else if(data.tables && data.tables.layer && data.tables.layer.layers[entity.layer])\r\n            color = data.tables.layer.layers[entity.layer].color;\r\n            \r\n        if(color == null || color === 0xffffff) {\r\n            color = 0x000000;\r\n        }\r\n        return color;\r\n    }\r\n\r\n    function createLineTypeShaders(data) {\r\n        var ltype, type;\r\n        if(!data.tables || !data.tables.lineType) return;\r\n        var ltypes = data.tables.lineType.lineTypes;\r\n\r\n        for(type in ltypes) {\r\n            ltype = ltypes[type];\r\n            if(!ltype.pattern) continue;\r\n            ltype.material = createDashedLineShader(ltype.pattern);\r\n        }\r\n    }\r\n\r\n    function createDashedLineShader(pattern) {\r\n        var i,\r\n            dashedLineShader = {},\r\n            totalLength = 0.0;\r\n\r\n        for(i = 0; i < pattern.length; i++) {\r\n            totalLength += Math.abs(pattern[i]);\r\n        }\r\n\r\n        dashedLineShader.uniforms = external_THREE_[\"UniformsUtils\"].merge([\r\n\r\n            external_THREE_[\"UniformsLib\"][ 'common' ],\r\n            external_THREE_[\"UniformsLib\"][ 'fog' ],\r\n\r\n            {\r\n                'pattern': { type: 'fv1', value: pattern },\r\n                'patternLength': { type: 'f', value: totalLength }\r\n            }\r\n\r\n        ]);\r\n\r\n        dashedLineShader.vertexShader = [\r\n            'attribute float lineDistance;',\r\n\r\n            'varying float vLineDistance;',\r\n\r\n            external_THREE_[\"ShaderChunk\"][ 'color_pars_vertex' ],\r\n\r\n            'void main() {',\r\n\r\n            external_THREE_[\"ShaderChunk\"][ 'color_vertex' ],\r\n\r\n            'vLineDistance = lineDistance;',\r\n\r\n            'gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );',\r\n\r\n            '}'\r\n        ].join('\\n');\r\n\r\n        dashedLineShader.fragmentShader = [\r\n            'uniform vec3 diffuse;',\r\n            'uniform float opacity;',\r\n\r\n            'uniform float pattern[' + pattern.length + '];',\r\n            'uniform float patternLength;',\r\n\r\n            'varying float vLineDistance;',\r\n\r\n            external_THREE_[\"ShaderChunk\"][ 'color_pars_fragment' ],\r\n            external_THREE_[\"ShaderChunk\"][ 'fog_pars_fragment' ],\r\n\r\n            'void main() {',\r\n\r\n            'float pos = mod(vLineDistance, patternLength);',\r\n\r\n            'for ( int i = 0; i < ' + pattern.length + '; i++ ) {',\r\n            'pos = pos - abs(pattern[i]);',\r\n            'if( pos < 0.0 ) {',\r\n            'if( pattern[i] > 0.0 ) {',\r\n            'gl_FragColor = vec4(1.0, 0.0, 0.0, opacity );',\r\n            'break;',\r\n            '}',\r\n            'discard;',\r\n            '}',\r\n\r\n            '}',\r\n\r\n            external_THREE_[\"ShaderChunk\"][ 'color_fragment' ],\r\n            external_THREE_[\"ShaderChunk\"][ 'fog_fragment' ],\r\n\r\n            '}'\r\n        ].join('\\n');\r\n\r\n        return dashedLineShader;\r\n    }\r\n\r\n    function findExtents(scene) { \r\n        for(var child of scene.children) {\r\n            var minX, maxX, minY, maxY;\r\n            if(child.position) {\r\n                minX = Math.min(child.position.x, minX);\r\n                minY = Math.min(child.position.y, minY);\r\n                maxX = Math.max(child.position.x, maxX);\r\n                maxY = Math.max(child.position.y, maxY);\r\n            }\r\n        }\r\n\r\n        return { min: { x: minX, y: minY }, max: { x: maxX, y: maxY }};\r\n    }\r\n\r\n}\r\n\r\n\r\n// Show/Hide helpers from https://plainjs.com/javascript/effects/hide-or-show-an-element-42/\r\n// get the default display style of an element\r\nfunction defaultDisplay(tag) {\r\n    var iframe = document.createElement('iframe');\r\n    iframe.setAttribute('frameborder', 0);\r\n    iframe.setAttribute('width', 0);\r\n    iframe.setAttribute('height', 0);\r\n    document.documentElement.appendChild(iframe);\r\n\r\n    var doc = (iframe.contentWindow || iframe.contentDocument).document;\r\n\r\n    // IE support\r\n    doc.write();\r\n    doc.close();\r\n\r\n    var testEl = doc.createElement(tag);\r\n    doc.documentElement.appendChild(testEl);\r\n    var display = (window.getComputedStyle ? getComputedStyle(testEl, null) : testEl.currentStyle).display\r\n    iframe.parentNode.removeChild(iframe);\r\n    return display;\r\n}\r\n\r\n// actual show/hide function used by show() and hide() below\r\nfunction showHide(el, show) {\r\n    var value = el.getAttribute('data-olddisplay'),\r\n    display = el.style.display,\r\n    computedDisplay = (window.getComputedStyle ? getComputedStyle(el, null) : el.currentStyle).display;\r\n\r\n    if (show) {\r\n        if (!value && display === 'none') el.style.display = '';\r\n        if (el.style.display === '' && (computedDisplay === 'none')) value = value || defaultDisplay(el.nodeName);\r\n    } else {\r\n        if (display && display !== 'none' || !(computedDisplay == 'none'))\r\n            el.setAttribute('data-olddisplay', (computedDisplay == 'none') ? display : computedDisplay);\r\n    }\r\n    if (!show || el.style.display === 'none' || el.style.display === '')\r\n        el.style.display = show ? value || '' : 'none';\r\n}\r\n\r\n// helper functions\r\nfunction show(el) { showHide(el, true); }\r\nfunction hide(el) { showHide(el); }\r\n\r\n\r\n\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9UaHJlZUR4Zi8uL3NyYy9PcmJpdENvbnRyb2xzLmpzP2UyMGYiLCJ3ZWJwYWNrOi8vVGhyZWVEeGYvLi9zcmMvaW5kZXguanM/YjYzNSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUUrQjs7QUFFeEI7O0FBRVA7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQkFBbUIsMEJBQWE7O0FBRWhDLDhCQUE4QjtBQUM5Qjs7QUFFQSxxREFBcUQ7QUFDckQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHdCQUF3Qjs7QUFFeEI7QUFDQTtBQUNBLDRCQUE0Qjs7QUFFNUI7QUFDQTtBQUNBLHdCQUF3QjtBQUN4Qiw4QkFBOEI7O0FBRTlCO0FBQ0E7O0FBRUE7QUFDQSxjQUFjOztBQUVkO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsdUJBQXVCLDBCQUFhO0FBQ3BDLHFCQUFxQiwwQkFBYTtBQUNsQyx1QkFBdUIsMEJBQWE7O0FBRXBDLG9CQUFvQiwwQkFBYTtBQUNqQyxrQkFBa0IsMEJBQWE7QUFDL0Isb0JBQW9CLDBCQUFhO0FBQ2pDLHFCQUFxQiwwQkFBYTs7QUFFbEMsa0JBQWtCLDBCQUFhOztBQUUvQixzQkFBc0IsMEJBQWE7QUFDbkMsb0JBQW9CLDBCQUFhO0FBQ2pDLHNCQUFzQiwwQkFBYTs7QUFFbkM7QUFDQTtBQUNBO0FBQ0EsZUFBZSwwQkFBYTs7QUFFNUIsd0JBQXdCLDBCQUFhOztBQUVyQyxjQUFjOztBQUVkOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsb0JBQW9CO0FBQ3BCLG1CQUFtQjtBQUNuQixpQkFBaUI7O0FBRWpCOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLEdBQUc7QUFDSDs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHO0FBQ0g7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxJQUFJOztBQUVKOztBQUVBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSx5Q0FBeUM7O0FBRXpDOztBQUVBLEdBQUcseUNBQXlDOztBQUU1Qzs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsc0VBQXNF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QUFZLDhCQUFpQjs7QUFFN0IsY0FBYztBQUNkOztBQUVBO0FBQ0E7O0FBRUEsaUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZ0JBQWdCLE9BQU8sbUJBQW1CLFFBQVE7QUFDbEQ7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtQkFBbUIsb0JBQW9CO0FBQ3ZDLG1CQUFtQixjQUFjIiwiZmlsZSI6IjEuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcclxuICogQGF1dGhvciBxaWFvIC8gaHR0cHM6Ly9naXRodWIuY29tL3FpYW9cclxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbVxyXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xyXG4gKiBAYXV0aG9yIFdlc3RMYW5nbGV5IC8gaHR0cDovL2dpdGh1Yi5jb20vV2VzdExhbmdsZXlcclxuICogQGF1dGhvciBlcmljaDY2NiAvIGh0dHA6Ly9lcmljaGFpbmVzLmNvbVxyXG4gKi9cclxuLypnbG9iYWwgVEhSRUUsIGNvbnNvbGUgKi9cclxuXHJcbi8vIFRoaXMgc2V0IG9mIGNvbnRyb2xzIHBlcmZvcm1zIG9yYml0aW5nLCBkb2xseWluZyAoem9vbWluZyksIGFuZCBwYW5uaW5nLiBJdCBtYWludGFpbnNcclxuLy8gdGhlIFwidXBcIiBkaXJlY3Rpb24gYXMgK1ksIHVubGlrZSB0aGUgVHJhY2tiYWxsQ29udHJvbHMuIFRvdWNoIG9uIHRhYmxldCBhbmQgcGhvbmVzIGlzXHJcbi8vIHN1cHBvcnRlZC5cclxuLy9cclxuLy8gICAgT3JiaXQgLSBsZWZ0IG1vdXNlIC8gdG91Y2g6IG9uZSBmaW5nZXIgbW92ZVxyXG4vLyAgICBab29tIC0gbWlkZGxlIG1vdXNlLCBvciBtb3VzZXdoZWVsIC8gdG91Y2g6IHR3byBmaW5nZXIgc3ByZWFkIG9yIHNxdWlzaFxyXG4vLyAgICBQYW4gLSByaWdodCBtb3VzZSwgb3IgYXJyb3cga2V5cyAvIHRvdWNoOiB0aHJlZSBmaW50ZXIgc3dpcGVcclxuLy9cclxuLy8gVGhpcyBpcyBhIGRyb3AtaW4gcmVwbGFjZW1lbnQgZm9yIChtb3N0KSBUcmFja2JhbGxDb250cm9scyB1c2VkIGluIGV4YW1wbGVzLlxyXG4vLyBUaGF0IGlzLCBpbmNsdWRlIHRoaXMganMgZmlsZSBhbmQgd2hlcmV2ZXIgeW91IHNlZTpcclxuLy8gICAgXHRjb250cm9scyA9IG5ldyBUSFJFRS5UcmFja2JhbGxDb250cm9scyggY2FtZXJhICk7XHJcbi8vICAgICAgY29udHJvbHMudGFyZ2V0LnogPSAxNTA7XHJcbi8vIFNpbXBsZSBzdWJzdGl0dXRlIFwiT3JiaXRDb250cm9sc1wiIGFuZCB0aGUgY29udHJvbCBzaG91bGQgd29yayBhcy1pcy5cclxuXHJcbmltcG9ydCAqIGFzIFRIUkVFIGZyb20gJ3RocmVlJztcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBPcmJpdENvbnRyb2xzKCBvYmplY3QsIGRvbUVsZW1lbnQgKSB7XHJcblxyXG5cdHRoaXMub2JqZWN0ID0gb2JqZWN0O1xyXG5cdHRoaXMuZG9tRWxlbWVudCA9ICggZG9tRWxlbWVudCAhPT0gdW5kZWZpbmVkICkgPyBkb21FbGVtZW50IDogZG9jdW1lbnQ7XHJcblxyXG5cdC8vIEFQSVxyXG5cclxuXHQvLyBTZXQgdG8gZmFsc2UgdG8gZGlzYWJsZSB0aGlzIGNvbnRyb2xcclxuXHR0aGlzLmVuYWJsZWQgPSB0cnVlO1xyXG5cclxuXHQvLyBcInRhcmdldFwiIHNldHMgdGhlIGxvY2F0aW9uIG9mIGZvY3VzLCB3aGVyZSB0aGUgY29udHJvbCBvcmJpdHMgYXJvdW5kXHJcblx0Ly8gYW5kIHdoZXJlIGl0IHBhbnMgd2l0aCByZXNwZWN0IHRvLlxyXG5cdHRoaXMudGFyZ2V0ID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHJcblx0Ly8gY2VudGVyIGlzIG9sZCwgZGVwcmVjYXRlZDsgdXNlIFwidGFyZ2V0XCIgaW5zdGVhZFxyXG5cdHRoaXMuY2VudGVyID0gdGhpcy50YXJnZXQ7XHJcblxyXG5cdC8vIFRoaXMgb3B0aW9uIGFjdHVhbGx5IGVuYWJsZXMgZG9sbHlpbmcgaW4gYW5kIG91dDsgbGVmdCBhcyBcInpvb21cIiBmb3JcclxuXHQvLyBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eVxyXG5cdHRoaXMubm9ab29tID0gZmFsc2U7XHJcblx0dGhpcy56b29tU3BlZWQgPSAxLjA7XHJcblxyXG5cdC8vIExpbWl0cyB0byBob3cgZmFyIHlvdSBjYW4gZG9sbHkgaW4gYW5kIG91dFxyXG5cdHRoaXMubWluRGlzdGFuY2UgPSAwO1xyXG5cdHRoaXMubWF4RGlzdGFuY2UgPSBJbmZpbml0eTtcclxuXHJcblx0Ly8gU2V0IHRvIHRydWUgdG8gZGlzYWJsZSB0aGlzIGNvbnRyb2xcclxuXHR0aGlzLm5vUm90YXRlID0gZmFsc2U7XHJcblx0dGhpcy5yb3RhdGVTcGVlZCA9IDEuMDtcclxuXHJcblx0Ly8gU2V0IHRvIHRydWUgdG8gZGlzYWJsZSB0aGlzIGNvbnRyb2xcclxuXHR0aGlzLm5vUGFuID0gZmFsc2U7XHJcblx0dGhpcy5rZXlQYW5TcGVlZCA9IDcuMDtcdC8vIHBpeGVscyBtb3ZlZCBwZXIgYXJyb3cga2V5IHB1c2hcclxuXHJcblx0Ly8gU2V0IHRvIHRydWUgdG8gYXV0b21hdGljYWxseSByb3RhdGUgYXJvdW5kIHRoZSB0YXJnZXRcclxuXHR0aGlzLmF1dG9Sb3RhdGUgPSBmYWxzZTtcclxuXHR0aGlzLmF1dG9Sb3RhdGVTcGVlZCA9IDIuMDsgLy8gMzAgc2Vjb25kcyBwZXIgcm91bmQgd2hlbiBmcHMgaXMgNjBcclxuXHJcblx0Ly8gSG93IGZhciB5b3UgY2FuIG9yYml0IHZlcnRpY2FsbHksIHVwcGVyIGFuZCBsb3dlciBsaW1pdHMuXHJcblx0Ly8gUmFuZ2UgaXMgMCB0byBNYXRoLlBJIHJhZGlhbnMuXHJcblx0dGhpcy5taW5Qb2xhckFuZ2xlID0gMDsgLy8gcmFkaWFuc1xyXG5cdHRoaXMubWF4UG9sYXJBbmdsZSA9IE1hdGguUEk7IC8vIHJhZGlhbnNcclxuXHJcblx0Ly8gU2V0IHRvIHRydWUgdG8gZGlzYWJsZSB1c2Ugb2YgdGhlIGtleXNcclxuXHR0aGlzLm5vS2V5cyA9IGZhbHNlO1xyXG5cclxuXHQvLyBUaGUgZm91ciBhcnJvdyBrZXlzXHJcblx0dGhpcy5rZXlzID0geyBMRUZUOiAzNywgVVA6IDM4LCBSSUdIVDogMzksIEJPVFRPTTogNDAgfTtcclxuXHJcblx0Ly8vLy8vLy8vLy8vXHJcblx0Ly8gaW50ZXJuYWxzXHJcblxyXG5cdHZhciBzY29wZSA9IHRoaXM7XHJcblxyXG5cdHZhciBFUFMgPSAwLjAwMDAwMTtcclxuXHJcblx0dmFyIHJvdGF0ZVN0YXJ0ID0gbmV3IFRIUkVFLlZlY3RvcjIoKTtcclxuXHR2YXIgcm90YXRlRW5kID0gbmV3IFRIUkVFLlZlY3RvcjIoKTtcclxuXHR2YXIgcm90YXRlRGVsdGEgPSBuZXcgVEhSRUUuVmVjdG9yMigpO1xyXG5cclxuXHR2YXIgcGFuU3RhcnQgPSBuZXcgVEhSRUUuVmVjdG9yMigpO1xyXG5cdHZhciBwYW5FbmQgPSBuZXcgVEhSRUUuVmVjdG9yMigpO1xyXG5cdHZhciBwYW5EZWx0YSA9IG5ldyBUSFJFRS5WZWN0b3IyKCk7XHJcblx0dmFyIHBhbk9mZnNldCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblxyXG5cdHZhciBvZmZzZXQgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cclxuXHR2YXIgZG9sbHlTdGFydCA9IG5ldyBUSFJFRS5WZWN0b3IyKCk7XHJcblx0dmFyIGRvbGx5RW5kID0gbmV3IFRIUkVFLlZlY3RvcjIoKTtcclxuXHR2YXIgZG9sbHlEZWx0YSA9IG5ldyBUSFJFRS5WZWN0b3IyKCk7XHJcblxyXG5cdHZhciBwaGlEZWx0YSA9IDA7XHJcblx0dmFyIHRoZXRhRGVsdGEgPSAwO1xyXG5cdHZhciBzY2FsZSA9IDE7XHJcblx0dmFyIHBhbiA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblxyXG5cdHZhciBsYXN0UG9zaXRpb24gPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cclxuXHR2YXIgU1RBVEUgPSB7IE5PTkUgOiAtMSwgUk9UQVRFIDogMCwgRE9MTFkgOiAxLCBQQU4gOiAyLCBUT1VDSF9ST1RBVEUgOiAzLCBUT1VDSF9ET0xMWSA6IDQsIFRPVUNIX1BBTiA6IDUgfTtcclxuXHJcblx0dmFyIHN0YXRlID0gU1RBVEUuTk9ORTtcclxuXHJcblx0Ly8gZm9yIHJlc2V0XHJcblxyXG5cdHRoaXMudGFyZ2V0MCA9IHRoaXMudGFyZ2V0LmNsb25lKCk7XHJcblx0dGhpcy5wb3NpdGlvbjAgPSB0aGlzLm9iamVjdC5wb3NpdGlvbi5jbG9uZSgpO1xyXG5cclxuXHQvLyBldmVudHNcclxuXHJcblx0dmFyIGNoYW5nZUV2ZW50ID0geyB0eXBlOiAnY2hhbmdlJyB9O1xyXG5cdHZhciBzdGFydEV2ZW50ID0geyB0eXBlOiAnc3RhcnQnfTtcclxuXHR2YXIgZW5kRXZlbnQgPSB7IHR5cGU6ICdlbmQnfTtcclxuXHJcblx0dGhpcy5yb3RhdGVMZWZ0ID0gZnVuY3Rpb24gKCBhbmdsZSApIHtcclxuXHJcblx0XHRpZiAoIGFuZ2xlID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRhbmdsZSA9IGdldEF1dG9Sb3RhdGlvbkFuZ2xlKCk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHRoZXRhRGVsdGEgLT0gYW5nbGU7XHJcblxyXG5cdH07XHJcblxyXG5cdHRoaXMucm90YXRlVXAgPSBmdW5jdGlvbiAoIGFuZ2xlICkge1xyXG5cclxuXHRcdGlmICggYW5nbGUgPT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdGFuZ2xlID0gZ2V0QXV0b1JvdGF0aW9uQW5nbGUoKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cGhpRGVsdGEgLT0gYW5nbGU7XHJcblxyXG5cdH07XHJcblxyXG5cdC8vIHBhc3MgaW4gZGlzdGFuY2UgaW4gd29ybGQgc3BhY2UgdG8gbW92ZSBsZWZ0XHJcblx0dGhpcy5wYW5MZWZ0ID0gZnVuY3Rpb24gKCBkaXN0YW5jZSApIHtcclxuXHJcblx0XHR2YXIgdGUgPSB0aGlzLm9iamVjdC5tYXRyaXguZWxlbWVudHM7XHJcblxyXG5cdFx0Ly8gZ2V0IFggY29sdW1uIG9mIG1hdHJpeFxyXG5cdFx0cGFuT2Zmc2V0LnNldCggdGVbIDAgXSwgdGVbIDEgXSwgdGVbIDIgXSApO1xyXG5cdFx0cGFuT2Zmc2V0Lm11bHRpcGx5U2NhbGFyKCAtIGRpc3RhbmNlICk7XHJcblx0XHRcclxuXHRcdHBhbi5hZGQoIHBhbk9mZnNldCApO1xyXG5cclxuXHR9O1xyXG5cclxuXHQvLyBwYXNzIGluIGRpc3RhbmNlIGluIHdvcmxkIHNwYWNlIHRvIG1vdmUgdXBcclxuXHR0aGlzLnBhblVwID0gZnVuY3Rpb24gKCBkaXN0YW5jZSApIHtcclxuXHJcblx0XHR2YXIgdGUgPSB0aGlzLm9iamVjdC5tYXRyaXguZWxlbWVudHM7XHJcblxyXG5cdFx0Ly8gZ2V0IFkgY29sdW1uIG9mIG1hdHJpeFxyXG5cdFx0cGFuT2Zmc2V0LnNldCggdGVbIDQgXSwgdGVbIDUgXSwgdGVbIDYgXSApO1xyXG5cdFx0cGFuT2Zmc2V0Lm11bHRpcGx5U2NhbGFyKCBkaXN0YW5jZSApO1xyXG5cdFx0XHJcblx0XHRwYW4uYWRkKCBwYW5PZmZzZXQgKTtcclxuXHJcblx0fTtcclxuXHRcclxuXHQvLyBwYXNzIGluIHgseSBvZiBjaGFuZ2UgZGVzaXJlZCBpbiBwaXhlbCBzcGFjZSxcclxuXHQvLyByaWdodCBhbmQgZG93biBhcmUgcG9zaXRpdmVcclxuXHR0aGlzLnBhbiA9IGZ1bmN0aW9uICggZGVsdGFYLCBkZWx0YVkgKSB7XHJcblxyXG5cdFx0dmFyIGVsZW1lbnQgPSBzY29wZS5kb21FbGVtZW50ID09PSBkb2N1bWVudCA/IHNjb3BlLmRvbUVsZW1lbnQuYm9keSA6IHNjb3BlLmRvbUVsZW1lbnQ7XHJcblxyXG5cdFx0aWYgKCBzY29wZS5vYmplY3QuZm92ICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHQvLyBwZXJzcGVjdGl2ZVxyXG5cdFx0XHR2YXIgcG9zaXRpb24gPSBzY29wZS5vYmplY3QucG9zaXRpb247XHJcblx0XHRcdHZhciBvZmZzZXQgPSBwb3NpdGlvbi5jbG9uZSgpLnN1Yiggc2NvcGUudGFyZ2V0ICk7XHJcblx0XHRcdHZhciB0YXJnZXREaXN0YW5jZSA9IG9mZnNldC5sZW5ndGgoKTtcclxuXHJcblx0XHRcdC8vIGhhbGYgb2YgdGhlIGZvdiBpcyBjZW50ZXIgdG8gdG9wIG9mIHNjcmVlblxyXG5cdFx0XHR0YXJnZXREaXN0YW5jZSAqPSBNYXRoLnRhbiggKCBzY29wZS5vYmplY3QuZm92IC8gMiApICogTWF0aC5QSSAvIDE4MC4wICk7XHJcblxyXG5cdFx0XHQvLyB3ZSBhY3R1YWxseSBkb24ndCB1c2Ugc2NyZWVuV2lkdGgsIHNpbmNlIHBlcnNwZWN0aXZlIGNhbWVyYSBpcyBmaXhlZCB0byBzY3JlZW4gaGVpZ2h0XHJcblx0XHRcdHNjb3BlLnBhbkxlZnQoIDIgKiBkZWx0YVggKiB0YXJnZXREaXN0YW5jZSAvIGVsZW1lbnQuY2xpZW50SGVpZ2h0ICk7XHJcblx0XHRcdHNjb3BlLnBhblVwKCAyICogZGVsdGFZICogdGFyZ2V0RGlzdGFuY2UgLyBlbGVtZW50LmNsaWVudEhlaWdodCApO1xyXG5cclxuXHRcdH0gZWxzZSBpZiAoIHNjb3BlLm9iamVjdC50b3AgIT09IHVuZGVmaW5lZCApIHtcclxuICAgICAgICAgICAgXHJcblx0XHRcdC8vIG9ydGhvZ3JhcGhpY1xyXG5cdFx0XHRzY29wZS5wYW5MZWZ0KCBkZWx0YVggKiAoc2NvcGUub2JqZWN0LnJpZ2h0IC0gc2NvcGUub2JqZWN0LmxlZnQpIC8gZWxlbWVudC5jbGllbnRXaWR0aCApO1xyXG5cdFx0XHRzY29wZS5wYW5VcCggZGVsdGFZICogKHNjb3BlLm9iamVjdC50b3AgLSBzY29wZS5vYmplY3QuYm90dG9tKSAvIGVsZW1lbnQuY2xpZW50SGVpZ2h0ICk7XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdC8vIGNhbWVyYSBuZWl0aGVyIG9ydGhvZ3JhcGhpYyBvciBwZXJzcGVjdGl2ZVxyXG5cdFx0XHRjb25zb2xlLndhcm4oICdXQVJOSU5HOiBPcmJpdENvbnRyb2xzLmpzIGVuY291bnRlcmVkIGFuIHVua25vd24gY2FtZXJhIHR5cGUgLSBwYW4gZGlzYWJsZWQuJyApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fTtcclxuXHJcblx0dGhpcy5kb2xseUluID0gZnVuY3Rpb24gKCBkb2xseVNjYWxlICkge1xyXG5cclxuXHRcdGlmICggZG9sbHlTY2FsZSA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0ZG9sbHlTY2FsZSA9IGdldFpvb21TY2FsZSgpO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRzY2FsZSAvPSBkb2xseVNjYWxlO1xyXG5cclxuXHR9O1xyXG5cclxuXHR0aGlzLmRvbGx5T3V0ID0gZnVuY3Rpb24gKCBkb2xseVNjYWxlICkge1xyXG5cclxuXHRcdGlmICggZG9sbHlTY2FsZSA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0ZG9sbHlTY2FsZSA9IGdldFpvb21TY2FsZSgpO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRzY2FsZSAqPSBkb2xseVNjYWxlO1xyXG5cclxuXHR9O1xyXG5cclxuXHR0aGlzLnVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBcclxuICAgICAgICBpZihzY29wZS5vYmplY3QudG9wICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5vYmplY3QudG9wID0gKHNjYWxlKnRoaXMub2JqZWN0LnRvcCk7XHJcbiAgICAgICAgICAgIHRoaXMub2JqZWN0LmJvdHRvbSA9IChzY2FsZSp0aGlzLm9iamVjdC5ib3R0b20pO1xyXG4gICAgICAgICAgICB0aGlzLm9iamVjdC5sZWZ0ID0gKHNjYWxlKnRoaXMub2JqZWN0LmxlZnQpO1xyXG4gICAgICAgICAgICB0aGlzLm9iamVjdC5yaWdodCA9IChzY2FsZSp0aGlzLm9iamVjdC5yaWdodCk7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICB0aGlzLm9iamVjdC51cGRhdGVQcm9qZWN0aW9uTWF0cml4KCk7XHJcblxyXG4gICAgICAgIH1cclxuICAgICAgICAgICAgXHJcblxyXG5cdFx0dmFyIHBvc2l0aW9uID0gdGhpcy5vYmplY3QucG9zaXRpb247XHJcblxyXG5cdFx0b2Zmc2V0LmNvcHkoIHBvc2l0aW9uICkuc3ViKCB0aGlzLnRhcmdldCApO1xyXG4vL1xyXG4vL1x0XHQvLyBhbmdsZSBmcm9tIHotYXhpcyBhcm91bmQgeS1heGlzXHJcbi8vXHJcbi8vXHRcdHZhciB0aGV0YSA9IE1hdGguYXRhbjIoIG9mZnNldC54LCBvZmZzZXQueiApO1xyXG4vL1xyXG4vL1x0XHQvLyBhbmdsZSBmcm9tIHktYXhpc1xyXG4vL1xyXG4vL1x0XHR2YXIgcGhpID0gTWF0aC5hdGFuMiggTWF0aC5zcXJ0KCBvZmZzZXQueCAqIG9mZnNldC54ICsgb2Zmc2V0LnogKiBvZmZzZXQueiApLCBvZmZzZXQueSApO1xyXG4vL1xyXG4vL1x0XHRpZiAoIHRoaXMuYXV0b1JvdGF0ZSApIHtcclxuLy9cclxuLy9cdFx0XHR0aGlzLnJvdGF0ZUxlZnQoIGdldEF1dG9Sb3RhdGlvbkFuZ2xlKCkgKTtcclxuLy9cclxuLy9cdFx0fVxyXG4vL1xyXG4vL1x0XHR0aGV0YSArPSB0aGV0YURlbHRhO1xyXG4vL1x0XHRwaGkgKz0gcGhpRGVsdGE7XHJcbi8vXHJcbi8vXHRcdC8vIHJlc3RyaWN0IHBoaSB0byBiZSBiZXR3ZWVuIGRlc2lyZWQgbGltaXRzXHJcbi8vXHRcdHBoaSA9IE1hdGgubWF4KCB0aGlzLm1pblBvbGFyQW5nbGUsIE1hdGgubWluKCB0aGlzLm1heFBvbGFyQW5nbGUsIHBoaSApICk7XHJcbi8vXHJcbi8vXHRcdC8vIHJlc3RyaWN0IHBoaSB0byBiZSBiZXR3ZWUgRVBTIGFuZCBQSS1FUFNcclxuLy9cdFx0cGhpID0gTWF0aC5tYXgoIEVQUywgTWF0aC5taW4oIE1hdGguUEkgLSBFUFMsIHBoaSApICk7XHJcbi8vXHJcbi8vXHRcdHZhciByYWRpdXMgPSBvZmZzZXQubGVuZ3RoKCkgKiBzY2FsZTtcclxuLy9cclxuLy9cdFx0Ly8gcmVzdHJpY3QgcmFkaXVzIHRvIGJlIGJldHdlZW4gZGVzaXJlZCBsaW1pdHNcclxuLy9cdFx0cmFkaXVzID0gTWF0aC5tYXgoIHRoaXMubWluRGlzdGFuY2UsIE1hdGgubWluKCB0aGlzLm1heERpc3RhbmNlLCByYWRpdXMgKSApO1xyXG4vL1x0XHRcclxuLy9cdFx0Ly8gbW92ZSB0YXJnZXQgdG8gcGFubmVkIGxvY2F0aW9uXHJcblx0XHR0aGlzLnRhcmdldC5hZGQoIHBhbiApO1xyXG4vL1x0XHRcclxuLy9cdFx0b2Zmc2V0LnggPSByYWRpdXMgKiBNYXRoLnNpbiggcGhpICkgKiBNYXRoLnNpbiggdGhldGEgKTtcclxuLy9cdFx0b2Zmc2V0LnkgPSByYWRpdXMgKiBNYXRoLmNvcyggcGhpICk7XHJcbi8vXHRcdG9mZnNldC56ID0gcmFkaXVzICogTWF0aC5zaW4oIHBoaSApICogTWF0aC5jb3MoIHRoZXRhICk7XHJcbi8vXHJcblx0XHRwb3NpdGlvbi5jb3B5KCB0aGlzLnRhcmdldCApLmFkZCggb2Zmc2V0ICk7XHJcblxyXG5cdFx0dGhpcy5vYmplY3QubG9va0F0KCB0aGlzLnRhcmdldCApO1xyXG5cclxuXHJcbi8vXHRcdGlmICggbGFzdFBvc2l0aW9uLmRpc3RhbmNlVG8oIHRoaXMub2JqZWN0LnBvc2l0aW9uICkgPiAwIHx8IHNjYWxlICE9PSAxICkge1xyXG5cclxuXHRcdFx0dGhpcy5kaXNwYXRjaEV2ZW50KCBjaGFuZ2VFdmVudCApO1xyXG5cclxuLy9cdFx0XHRsYXN0UG9zaXRpb24uY29weSggdGhpcy5vYmplY3QucG9zaXRpb24gKTtcclxuXHJcbi8vXHRcdH1cclxuICAgICAgICBcclxuLy8gICAgICAgIHRoZXRhRGVsdGEgPSAwO1xyXG4vL1x0XHRwaGlEZWx0YSA9IDA7XHJcblx0XHRzY2FsZSA9IDE7XHJcblx0XHRwYW4uc2V0KCAwLCAwLCAwICk7XHJcblxyXG5cdH07XHJcblxyXG5cclxuXHR0aGlzLnJlc2V0ID0gZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHN0YXRlID0gU1RBVEUuTk9ORTtcclxuXHJcblx0XHR0aGlzLnRhcmdldC5jb3B5KCB0aGlzLnRhcmdldDAgKTtcclxuXHRcdHRoaXMub2JqZWN0LnBvc2l0aW9uLmNvcHkoIHRoaXMucG9zaXRpb24wICk7XHJcblxyXG5cdFx0dGhpcy51cGRhdGUoKTtcclxuXHJcblx0fTtcclxuXHJcblx0ZnVuY3Rpb24gZ2V0QXV0b1JvdGF0aW9uQW5nbGUoKSB7XHJcblxyXG5cdFx0cmV0dXJuIDIgKiBNYXRoLlBJIC8gNjAgLyA2MCAqIHNjb3BlLmF1dG9Sb3RhdGVTcGVlZDtcclxuXHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBnZXRab29tU2NhbGUoKSB7XHJcblxyXG5cdFx0cmV0dXJuIE1hdGgucG93KCAwLjk1LCBzY29wZS56b29tU3BlZWQgKTtcclxuXHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBvbk1vdXNlRG93biggZXZlbnQgKSB7XHJcblxyXG5cdFx0aWYgKCBzY29wZS5lbmFibGVkID09PSBmYWxzZSApIHJldHVybjtcclxuXHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XHJcblxyXG5cdFx0aWYgKCBldmVudC5idXR0b24gPT09IDAgKSB7XHJcblx0XHRcdGlmICggc2NvcGUubm9Sb3RhdGUgPT09IHRydWUgKSByZXR1cm47XHJcblxyXG5cdFx0XHRzdGF0ZSA9IFNUQVRFLlJPVEFURTtcclxuXHJcblx0XHRcdHJvdGF0ZVN0YXJ0LnNldCggZXZlbnQuY2xpZW50WCwgZXZlbnQuY2xpZW50WSApO1xyXG5cclxuXHRcdH0gZWxzZSBpZiAoIGV2ZW50LmJ1dHRvbiA9PT0gMSApIHtcclxuXHRcdFx0aWYgKCBzY29wZS5ub1pvb20gPT09IHRydWUgKSByZXR1cm47XHJcblxyXG5cdFx0XHRzdGF0ZSA9IFNUQVRFLkRPTExZO1xyXG5cclxuXHRcdFx0ZG9sbHlTdGFydC5zZXQoIGV2ZW50LmNsaWVudFgsIGV2ZW50LmNsaWVudFkgKTtcclxuXHJcblx0XHR9IGVsc2UgaWYgKCBldmVudC5idXR0b24gPT09IDIgKSB7XHJcblx0XHRcdGlmICggc2NvcGUubm9QYW4gPT09IHRydWUgKSByZXR1cm47XHJcblxyXG5cdFx0XHRzdGF0ZSA9IFNUQVRFLlBBTjtcclxuXHJcblx0XHRcdHBhblN0YXJ0LnNldCggZXZlbnQuY2xpZW50WCwgZXZlbnQuY2xpZW50WSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRzY29wZS5kb21FbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoICdtb3VzZW1vdmUnLCBvbk1vdXNlTW92ZSwgZmFsc2UgKTtcclxuXHRcdHNjb3BlLmRvbUVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lciggJ21vdXNldXAnLCBvbk1vdXNlVXAsIGZhbHNlICk7XHJcblx0XHRzY29wZS5kaXNwYXRjaEV2ZW50KCBzdGFydEV2ZW50ICk7XHJcblxyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gb25Nb3VzZU1vdmUoIGV2ZW50ICkge1xyXG5cclxuXHRcdGlmICggc2NvcGUuZW5hYmxlZCA9PT0gZmFsc2UgKSByZXR1cm47XHJcblxyXG5cdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcclxuXHJcblx0XHR2YXIgZWxlbWVudCA9IHNjb3BlLmRvbUVsZW1lbnQgPT09IGRvY3VtZW50ID8gc2NvcGUuZG9tRWxlbWVudC5ib2R5IDogc2NvcGUuZG9tRWxlbWVudDtcclxuXHJcblx0XHRpZiAoIHN0YXRlID09PSBTVEFURS5ST1RBVEUgKSB7XHJcblxyXG5cdFx0XHRpZiAoIHNjb3BlLm5vUm90YXRlID09PSB0cnVlICkgcmV0dXJuO1xyXG5cclxuXHRcdFx0cm90YXRlRW5kLnNldCggZXZlbnQuY2xpZW50WCwgZXZlbnQuY2xpZW50WSApO1xyXG5cdFx0XHRyb3RhdGVEZWx0YS5zdWJWZWN0b3JzKCByb3RhdGVFbmQsIHJvdGF0ZVN0YXJ0ICk7XHJcblxyXG5cdFx0XHQvLyByb3RhdGluZyBhY3Jvc3Mgd2hvbGUgc2NyZWVuIGdvZXMgMzYwIGRlZ3JlZXMgYXJvdW5kXHJcblx0XHRcdHNjb3BlLnJvdGF0ZUxlZnQoIDIgKiBNYXRoLlBJICogcm90YXRlRGVsdGEueCAvIGVsZW1lbnQuY2xpZW50V2lkdGggKiBzY29wZS5yb3RhdGVTcGVlZCApO1xyXG5cclxuXHRcdFx0Ly8gcm90YXRpbmcgdXAgYW5kIGRvd24gYWxvbmcgd2hvbGUgc2NyZWVuIGF0dGVtcHRzIHRvIGdvIDM2MCwgYnV0IGxpbWl0ZWQgdG8gMTgwXHJcblx0XHRcdHNjb3BlLnJvdGF0ZVVwKCAyICogTWF0aC5QSSAqIHJvdGF0ZURlbHRhLnkgLyBlbGVtZW50LmNsaWVudEhlaWdodCAqIHNjb3BlLnJvdGF0ZVNwZWVkICk7XHJcblxyXG5cdFx0XHRyb3RhdGVTdGFydC5jb3B5KCByb3RhdGVFbmQgKTtcclxuXHJcblx0XHR9IGVsc2UgaWYgKCBzdGF0ZSA9PT0gU1RBVEUuRE9MTFkgKSB7XHJcblxyXG5cdFx0XHRpZiAoIHNjb3BlLm5vWm9vbSA9PT0gdHJ1ZSApIHJldHVybjtcclxuXHJcblx0XHRcdGRvbGx5RW5kLnNldCggZXZlbnQuY2xpZW50WCwgZXZlbnQuY2xpZW50WSApO1xyXG5cdFx0XHRkb2xseURlbHRhLnN1YlZlY3RvcnMoIGRvbGx5RW5kLCBkb2xseVN0YXJ0ICk7XHJcblxyXG5cdFx0XHRpZiAoIGRvbGx5RGVsdGEueSA+IDAgKSB7XHJcblxyXG5cdFx0XHRcdHNjb3BlLmRvbGx5SW4oKTtcclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdHNjb3BlLmRvbGx5T3V0KCk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRkb2xseVN0YXJ0LmNvcHkoIGRvbGx5RW5kICk7XHJcblxyXG5cdFx0fSBlbHNlIGlmICggc3RhdGUgPT09IFNUQVRFLlBBTiApIHtcclxuXHJcblx0XHRcdGlmICggc2NvcGUubm9QYW4gPT09IHRydWUgKSByZXR1cm47XHJcblxyXG5cdFx0XHRwYW5FbmQuc2V0KCBldmVudC5jbGllbnRYLCBldmVudC5jbGllbnRZICk7XHJcblx0XHRcdHBhbkRlbHRhLnN1YlZlY3RvcnMoIHBhbkVuZCwgcGFuU3RhcnQgKTtcclxuXHRcdFx0XHJcblx0XHRcdHNjb3BlLnBhbiggcGFuRGVsdGEueCwgcGFuRGVsdGEueSApO1xyXG5cclxuXHRcdFx0cGFuU3RhcnQuY29weSggcGFuRW5kICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHNjb3BlLnVwZGF0ZSgpO1xyXG5cclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIG9uTW91c2VVcCggLyogZXZlbnQgKi8gKSB7XHJcblxyXG5cdFx0aWYgKCBzY29wZS5lbmFibGVkID09PSBmYWxzZSApIHJldHVybjtcclxuXHJcblx0XHRzY29wZS5kb21FbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoICdtb3VzZW1vdmUnLCBvbk1vdXNlTW92ZSwgZmFsc2UgKTtcclxuXHRcdHNjb3BlLmRvbUVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ21vdXNldXAnLCBvbk1vdXNlVXAsIGZhbHNlICk7XHJcblx0XHRzY29wZS5kaXNwYXRjaEV2ZW50KCBlbmRFdmVudCApO1xyXG5cdFx0c3RhdGUgPSBTVEFURS5OT05FO1xyXG5cclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIG9uTW91c2VXaGVlbCggZXZlbnQgKSB7XHJcblxyXG5cdFx0aWYgKCBzY29wZS5lbmFibGVkID09PSBmYWxzZSB8fCBzY29wZS5ub1pvb20gPT09IHRydWUgKSByZXR1cm47XHJcblxyXG5cdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcclxuXHJcblx0XHR2YXIgZGVsdGEgPSAwO1xyXG5cclxuXHRcdGlmICggZXZlbnQud2hlZWxEZWx0YSAhPT0gdW5kZWZpbmVkICkgeyAvLyBXZWJLaXQgLyBPcGVyYSAvIEV4cGxvcmVyIDlcclxuXHJcblx0XHRcdGRlbHRhID0gZXZlbnQud2hlZWxEZWx0YTtcclxuXHJcblx0XHR9IGVsc2UgaWYgKCBldmVudC5kZXRhaWwgIT09IHVuZGVmaW5lZCApIHsgLy8gRmlyZWZveFxyXG5cclxuXHRcdFx0ZGVsdGEgPSAtIGV2ZW50LmRldGFpbDtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCBkZWx0YSA+IDAgKSB7XHJcblxyXG5cdFx0XHRzY29wZS5kb2xseU91dCgpO1xyXG5cclxuXHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRzY29wZS5kb2xseUluKCk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHNjb3BlLnVwZGF0ZSgpO1xyXG5cdFx0c2NvcGUuZGlzcGF0Y2hFdmVudCggc3RhcnRFdmVudCApO1xyXG5cdFx0c2NvcGUuZGlzcGF0Y2hFdmVudCggZW5kRXZlbnQgKTtcclxuXHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBvbktleURvd24oIGV2ZW50ICkge1xyXG5cclxuXHRcdGlmICggc2NvcGUuZW5hYmxlZCA9PT0gZmFsc2UgfHwgc2NvcGUubm9LZXlzID09PSB0cnVlIHx8IHNjb3BlLm5vUGFuID09PSB0cnVlICkgcmV0dXJuO1xyXG5cdFx0XHJcblx0XHRzd2l0Y2ggKCBldmVudC5rZXlDb2RlICkge1xyXG5cclxuXHRcdFx0Y2FzZSBzY29wZS5rZXlzLlVQOlxyXG5cdFx0XHRcdHNjb3BlLnBhbiggMCwgc2NvcGUua2V5UGFuU3BlZWQgKTtcclxuXHRcdFx0XHRzY29wZS51cGRhdGUoKTtcclxuXHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdGNhc2Ugc2NvcGUua2V5cy5CT1RUT006XHJcblx0XHRcdFx0c2NvcGUucGFuKCAwLCAtIHNjb3BlLmtleVBhblNwZWVkICk7XHJcblx0XHRcdFx0c2NvcGUudXBkYXRlKCk7XHJcblx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRjYXNlIHNjb3BlLmtleXMuTEVGVDpcclxuXHRcdFx0XHRzY29wZS5wYW4oIHNjb3BlLmtleVBhblNwZWVkLCAwICk7XHJcblx0XHRcdFx0c2NvcGUudXBkYXRlKCk7XHJcblx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRjYXNlIHNjb3BlLmtleXMuUklHSFQ6XHJcblx0XHRcdFx0c2NvcGUucGFuKCAtIHNjb3BlLmtleVBhblNwZWVkLCAwICk7XHJcblx0XHRcdFx0c2NvcGUudXBkYXRlKCk7XHJcblx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIHRvdWNoc3RhcnQoIGV2ZW50ICkge1xyXG5cclxuXHRcdGlmICggc2NvcGUuZW5hYmxlZCA9PT0gZmFsc2UgKSByZXR1cm47XHJcblxyXG5cdFx0c3dpdGNoICggZXZlbnQudG91Y2hlcy5sZW5ndGggKSB7XHJcblxyXG5cdFx0XHRjYXNlIDE6XHQvLyBvbmUtZmluZ2VyZWQgdG91Y2g6IHJvdGF0ZVxyXG5cclxuXHRcdFx0XHRpZiAoIHNjb3BlLm5vUm90YXRlID09PSB0cnVlICkgcmV0dXJuO1xyXG5cclxuXHRcdFx0XHRzdGF0ZSA9IFNUQVRFLlRPVUNIX1JPVEFURTtcclxuXHJcblx0XHRcdFx0cm90YXRlU3RhcnQuc2V0KCBldmVudC50b3VjaGVzWyAwIF0ucGFnZVgsIGV2ZW50LnRvdWNoZXNbIDAgXS5wYWdlWSApO1xyXG5cdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0Y2FzZSAyOlx0Ly8gdHdvLWZpbmdlcmVkIHRvdWNoOiBkb2xseVxyXG5cclxuXHRcdFx0XHRpZiAoIHNjb3BlLm5vWm9vbSA9PT0gdHJ1ZSApIHJldHVybjtcclxuXHJcblx0XHRcdFx0c3RhdGUgPSBTVEFURS5UT1VDSF9ET0xMWTtcclxuXHJcblx0XHRcdFx0dmFyIGR4ID0gZXZlbnQudG91Y2hlc1sgMCBdLnBhZ2VYIC0gZXZlbnQudG91Y2hlc1sgMSBdLnBhZ2VYO1xyXG5cdFx0XHRcdHZhciBkeSA9IGV2ZW50LnRvdWNoZXNbIDAgXS5wYWdlWSAtIGV2ZW50LnRvdWNoZXNbIDEgXS5wYWdlWTtcclxuXHRcdFx0XHR2YXIgZGlzdGFuY2UgPSBNYXRoLnNxcnQoIGR4ICogZHggKyBkeSAqIGR5ICk7XHJcblx0XHRcdFx0ZG9sbHlTdGFydC5zZXQoIDAsIGRpc3RhbmNlICk7XHJcblx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRjYXNlIDM6IC8vIHRocmVlLWZpbmdlcmVkIHRvdWNoOiBwYW5cclxuXHJcblx0XHRcdFx0aWYgKCBzY29wZS5ub1BhbiA9PT0gdHJ1ZSApIHJldHVybjtcclxuXHJcblx0XHRcdFx0c3RhdGUgPSBTVEFURS5UT1VDSF9QQU47XHJcblxyXG5cdFx0XHRcdHBhblN0YXJ0LnNldCggZXZlbnQudG91Y2hlc1sgMCBdLnBhZ2VYLCBldmVudC50b3VjaGVzWyAwIF0ucGFnZVkgKTtcclxuXHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdGRlZmF1bHQ6XHJcblxyXG5cdFx0XHRcdHN0YXRlID0gU1RBVEUuTk9ORTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0c2NvcGUuZGlzcGF0Y2hFdmVudCggc3RhcnRFdmVudCApO1xyXG5cclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIHRvdWNobW92ZSggZXZlbnQgKSB7XHJcblxyXG5cdFx0aWYgKCBzY29wZS5lbmFibGVkID09PSBmYWxzZSApIHJldHVybjtcclxuXHJcblx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xyXG5cdFx0ZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XHJcblxyXG5cdFx0dmFyIGVsZW1lbnQgPSBzY29wZS5kb21FbGVtZW50ID09PSBkb2N1bWVudCA/IHNjb3BlLmRvbUVsZW1lbnQuYm9keSA6IHNjb3BlLmRvbUVsZW1lbnQ7XHJcblxyXG5cdFx0c3dpdGNoICggZXZlbnQudG91Y2hlcy5sZW5ndGggKSB7XHJcblxyXG5cdFx0XHRjYXNlIDE6IC8vIG9uZS1maW5nZXJlZCB0b3VjaDogcm90YXRlXHJcblxyXG5cdFx0XHRcdGlmICggc2NvcGUubm9Sb3RhdGUgPT09IHRydWUgKSByZXR1cm47XHJcblx0XHRcdFx0aWYgKCBzdGF0ZSAhPT0gU1RBVEUuVE9VQ0hfUk9UQVRFICkgcmV0dXJuO1xyXG5cclxuXHRcdFx0XHRyb3RhdGVFbmQuc2V0KCBldmVudC50b3VjaGVzWyAwIF0ucGFnZVgsIGV2ZW50LnRvdWNoZXNbIDAgXS5wYWdlWSApO1xyXG5cdFx0XHRcdHJvdGF0ZURlbHRhLnN1YlZlY3RvcnMoIHJvdGF0ZUVuZCwgcm90YXRlU3RhcnQgKTtcclxuXHJcblx0XHRcdFx0Ly8gcm90YXRpbmcgYWNyb3NzIHdob2xlIHNjcmVlbiBnb2VzIDM2MCBkZWdyZWVzIGFyb3VuZFxyXG5cdFx0XHRcdHNjb3BlLnJvdGF0ZUxlZnQoIDIgKiBNYXRoLlBJICogcm90YXRlRGVsdGEueCAvIGVsZW1lbnQuY2xpZW50V2lkdGggKiBzY29wZS5yb3RhdGVTcGVlZCApO1xyXG5cdFx0XHRcdC8vIHJvdGF0aW5nIHVwIGFuZCBkb3duIGFsb25nIHdob2xlIHNjcmVlbiBhdHRlbXB0cyB0byBnbyAzNjAsIGJ1dCBsaW1pdGVkIHRvIDE4MFxyXG5cdFx0XHRcdHNjb3BlLnJvdGF0ZVVwKCAyICogTWF0aC5QSSAqIHJvdGF0ZURlbHRhLnkgLyBlbGVtZW50LmNsaWVudEhlaWdodCAqIHNjb3BlLnJvdGF0ZVNwZWVkICk7XHJcblxyXG5cdFx0XHRcdHJvdGF0ZVN0YXJ0LmNvcHkoIHJvdGF0ZUVuZCApO1xyXG5cclxuXHRcdFx0XHRzY29wZS51cGRhdGUoKTtcclxuXHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdGNhc2UgMjogLy8gdHdvLWZpbmdlcmVkIHRvdWNoOiBkb2xseVxyXG5cclxuXHRcdFx0XHRpZiAoIHNjb3BlLm5vWm9vbSA9PT0gdHJ1ZSApIHJldHVybjtcclxuXHRcdFx0XHRpZiAoIHN0YXRlICE9PSBTVEFURS5UT1VDSF9ET0xMWSApIHJldHVybjtcclxuXHJcblx0XHRcdFx0dmFyIGR4ID0gZXZlbnQudG91Y2hlc1sgMCBdLnBhZ2VYIC0gZXZlbnQudG91Y2hlc1sgMSBdLnBhZ2VYO1xyXG5cdFx0XHRcdHZhciBkeSA9IGV2ZW50LnRvdWNoZXNbIDAgXS5wYWdlWSAtIGV2ZW50LnRvdWNoZXNbIDEgXS5wYWdlWTtcclxuXHRcdFx0XHR2YXIgZGlzdGFuY2UgPSBNYXRoLnNxcnQoIGR4ICogZHggKyBkeSAqIGR5ICk7XHJcblxyXG5cdFx0XHRcdGRvbGx5RW5kLnNldCggMCwgZGlzdGFuY2UgKTtcclxuXHRcdFx0XHRkb2xseURlbHRhLnN1YlZlY3RvcnMoIGRvbGx5RW5kLCBkb2xseVN0YXJ0ICk7XHJcblxyXG5cdFx0XHRcdGlmICggZG9sbHlEZWx0YS55ID4gMCApIHtcclxuXHJcblx0XHRcdFx0XHRzY29wZS5kb2xseU91dCgpO1xyXG5cclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdHNjb3BlLmRvbGx5SW4oKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRkb2xseVN0YXJ0LmNvcHkoIGRvbGx5RW5kICk7XHJcblxyXG5cdFx0XHRcdHNjb3BlLnVwZGF0ZSgpO1xyXG5cdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0Y2FzZSAzOiAvLyB0aHJlZS1maW5nZXJlZCB0b3VjaDogcGFuXHJcblxyXG5cdFx0XHRcdGlmICggc2NvcGUubm9QYW4gPT09IHRydWUgKSByZXR1cm47XHJcblx0XHRcdFx0aWYgKCBzdGF0ZSAhPT0gU1RBVEUuVE9VQ0hfUEFOICkgcmV0dXJuO1xyXG5cclxuXHRcdFx0XHRwYW5FbmQuc2V0KCBldmVudC50b3VjaGVzWyAwIF0ucGFnZVgsIGV2ZW50LnRvdWNoZXNbIDAgXS5wYWdlWSApO1xyXG5cdFx0XHRcdHBhbkRlbHRhLnN1YlZlY3RvcnMoIHBhbkVuZCwgcGFuU3RhcnQgKTtcclxuXHRcdFx0XHRcclxuXHRcdFx0XHRzY29wZS5wYW4oIHBhbkRlbHRhLngsIHBhbkRlbHRhLnkgKTtcclxuXHJcblx0XHRcdFx0cGFuU3RhcnQuY29weSggcGFuRW5kICk7XHJcblxyXG5cdFx0XHRcdHNjb3BlLnVwZGF0ZSgpO1xyXG5cdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0ZGVmYXVsdDpcclxuXHJcblx0XHRcdFx0c3RhdGUgPSBTVEFURS5OT05FO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiB0b3VjaGVuZCggLyogZXZlbnQgKi8gKSB7XHJcblxyXG5cdFx0aWYgKCBzY29wZS5lbmFibGVkID09PSBmYWxzZSApIHJldHVybjtcclxuXHJcblx0XHRzY29wZS5kaXNwYXRjaEV2ZW50KCBlbmRFdmVudCApO1xyXG5cdFx0c3RhdGUgPSBTVEFURS5OT05FO1xyXG5cclxuXHR9XHJcblxyXG5cdHRoaXMuZG9tRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCAnY29udGV4dG1lbnUnLCBmdW5jdGlvbiAoIGV2ZW50ICkgeyBldmVudC5wcmV2ZW50RGVmYXVsdCgpOyB9LCBmYWxzZSApO1xyXG5cdHRoaXMuZG9tRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCAnbW91c2Vkb3duJywgb25Nb3VzZURvd24sIGZhbHNlICk7XHJcblx0dGhpcy5kb21FbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoICdtb3VzZXdoZWVsJywgb25Nb3VzZVdoZWVsLCBmYWxzZSApO1xyXG5cdHRoaXMuZG9tRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCAnRE9NTW91c2VTY3JvbGwnLCBvbk1vdXNlV2hlZWwsIGZhbHNlICk7IC8vIGZpcmVmb3hcclxuXHJcblx0dGhpcy5kb21FbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoICd0b3VjaHN0YXJ0JywgdG91Y2hzdGFydCwgZmFsc2UgKTtcclxuXHR0aGlzLmRvbUVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lciggJ3RvdWNoZW5kJywgdG91Y2hlbmQsIGZhbHNlICk7XHJcblx0dGhpcy5kb21FbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoICd0b3VjaG1vdmUnLCB0b3VjaG1vdmUsIGZhbHNlICk7XHJcblxyXG5cdHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCAna2V5ZG93bicsIG9uS2V5RG93biwgZmFsc2UgKTtcclxuXHJcbn07XHJcblxyXG5PcmJpdENvbnRyb2xzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkV2ZW50RGlzcGF0Y2hlci5wcm90b3R5cGUgKTsiLCJpbXBvcnQgKiBhcyBUSFJFRSBmcm9tICd0aHJlZSc7XHJcbmltcG9ydCB7IE9yYml0Q29udHJvbHMgfSBmcm9tICcuL09yYml0Q29udHJvbHMnO1xyXG5cclxuLy8gVGhyZWUuanMgZXh0ZW5zaW9uIGZ1bmN0aW9ucy4gV2VicGFjayBkb2Vzbid0IHNlZW0gdG8gbGlrZSBpdCBpZiB3ZSBtb2RpZnkgdGhlIFRIUkVFIG9iamVjdCBkaXJlY3RseS5cclxudmFyIFRIUkVFeCA9IHsgTWF0aDoge30gfTtcclxuLyoqXHJcbiAqIFJldHVybnMgdGhlIGFuZ2xlIGluIHJhZGlhbnMgb2YgdGhlIHZlY3RvciAocDEscDIpLiBJbiBvdGhlciB3b3JkcywgaW1hZ2luZVxyXG4gKiBwdXR0aW5nIHRoZSBiYXNlIG9mIHRoZSB2ZWN0b3IgYXQgY29vcmRpbmF0ZXMgKDAsMCkgYW5kIGZpbmRpbmcgdGhlIGFuZ2xlXHJcbiAqIGZyb20gdmVjdG9yICgxLDApIHRvIChwMSxwMikuXHJcbiAqIEBwYXJhbSAge09iamVjdH0gcDEgc3RhcnQgcG9pbnQgb2YgdGhlIHZlY3RvclxyXG4gKiBAcGFyYW0gIHtPYmplY3R9IHAyIGVuZCBwb2ludCBvZiB0aGUgdmVjdG9yXHJcbiAqIEByZXR1cm4ge051bWJlcn0gdGhlIGFuZ2xlXHJcbiAqL1xyXG5USFJFRXguTWF0aC5hbmdsZTIgPSBmdW5jdGlvbihwMSwgcDIpIHtcclxuXHR2YXIgdjEgPSBuZXcgVEhSRUUuVmVjdG9yMihwMS54LCBwMS55KTtcclxuXHR2YXIgdjIgPSBuZXcgVEhSRUUuVmVjdG9yMihwMi54LCBwMi55KTtcclxuXHR2Mi5zdWIodjEpOyAvLyBzZXRzIHYyIHRvIGJlIG91ciBjaG9yZFxyXG5cdHYyLm5vcm1hbGl6ZSgpO1xyXG5cdGlmKHYyLnkgPCAwKSByZXR1cm4gLU1hdGguYWNvcyh2Mi54KTtcclxuXHRyZXR1cm4gTWF0aC5hY29zKHYyLngpO1xyXG59O1xyXG5cclxuXHJcblRIUkVFeC5NYXRoLnBvbGFyID0gZnVuY3Rpb24ocG9pbnQsIGRpc3RhbmNlLCBhbmdsZSkge1xyXG5cdHZhciByZXN1bHQgPSB7fTtcclxuXHRyZXN1bHQueCA9IHBvaW50LnggKyBkaXN0YW5jZSAqIE1hdGguY29zKGFuZ2xlKTtcclxuXHRyZXN1bHQueSA9IHBvaW50LnkgKyBkaXN0YW5jZSAqIE1hdGguc2luKGFuZ2xlKTtcclxuXHRyZXR1cm4gcmVzdWx0O1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIENhbGN1bGF0ZXMgcG9pbnRzIGZvciBhIGN1cnZlIGJldHdlZW4gdHdvIHBvaW50c1xyXG4gKiBAcGFyYW0gc3RhcnRQb2ludCAtIHRoZSBzdGFydGluZyBwb2ludCBvZiB0aGUgY3VydmVcclxuICogQHBhcmFtIGVuZFBvaW50IC0gdGhlIGVuZGluZyBwb2ludCBvZiB0aGUgY3VydmVcclxuICogQHBhcmFtIGJ1bGdlIC0gYSB2YWx1ZSBpbmRpY2F0aW5nIGhvdyBtdWNoIHRvIGN1cnZlXHJcbiAqIEBwYXJhbSBzZWdtZW50cyAtIG51bWJlciBvZiBzZWdtZW50cyBiZXR3ZWVuIHRoZSB0d28gZ2l2ZW4gcG9pbnRzXHJcbiAqL1xyXG5USFJFRXguQnVsZ2VHZW9tZXRyeSA9IGZ1bmN0aW9uICggc3RhcnRQb2ludCwgZW5kUG9pbnQsIGJ1bGdlLCBzZWdtZW50cyApIHtcclxuXHJcblx0dmFyIHZlcnRleCwgaSxcclxuXHRcdGNlbnRlciwgcDAsIHAxLCBhbmdsZSxcclxuXHRcdHJhZGl1cywgc3RhcnRBbmdsZSxcclxuXHRcdHRoZXRhQW5nbGU7XHJcblxyXG5cdFRIUkVFLkdlb21ldHJ5LmNhbGwoIHRoaXMgKTtcclxuXHJcblx0dGhpcy5zdGFydFBvaW50ID0gcDAgPSBzdGFydFBvaW50ID8gbmV3IFRIUkVFLlZlY3RvcjIoc3RhcnRQb2ludC54LCBzdGFydFBvaW50LnkpIDogbmV3IFRIUkVFLlZlY3RvcjIoMCwwKTtcclxuXHR0aGlzLmVuZFBvaW50ID0gcDEgPSBlbmRQb2ludCA/IG5ldyBUSFJFRS5WZWN0b3IyKGVuZFBvaW50LngsIGVuZFBvaW50LnkpIDogbmV3IFRIUkVFLlZlY3RvcjIoMSwwKTtcclxuXHR0aGlzLmJ1bGdlID0gYnVsZ2UgPSBidWxnZSB8fCAxO1xyXG5cclxuXHRhbmdsZSA9IDQgKiBNYXRoLmF0YW4oYnVsZ2UpO1xyXG5cdHJhZGl1cyA9IHAwLmRpc3RhbmNlVG8ocDEpIC8gMiAvIE1hdGguc2luKGFuZ2xlLzIpO1xyXG5cdGNlbnRlciA9IFRIUkVFeC5NYXRoLnBvbGFyKHN0YXJ0UG9pbnQsIHJhZGl1cywgVEhSRUV4Lk1hdGguYW5nbGUyKHAwLHAxKSArIChNYXRoLlBJIC8gMiAtIGFuZ2xlLzIpKTtcclxuXHJcblx0dGhpcy5zZWdtZW50cyA9IHNlZ21lbnRzID0gc2VnbWVudHMgfHwgTWF0aC5tYXgoIE1hdGguYWJzKE1hdGguY2VpbChhbmdsZS8oTWF0aC5QSS8xOCkpKSwgNik7IC8vIEJ5IGRlZmF1bHQgd2FudCBhIHNlZ21lbnQgcm91Z2hseSBldmVyeSAxMCBkZWdyZWVzXHJcblx0c3RhcnRBbmdsZSA9IFRIUkVFeC5NYXRoLmFuZ2xlMihjZW50ZXIsIHAwKTtcclxuXHR0aGV0YUFuZ2xlID0gYW5nbGUgLyBzZWdtZW50cztcclxuXHJcblxyXG5cdHRoaXMudmVydGljZXMucHVzaChuZXcgVEhSRUUuVmVjdG9yMyhwMC54LCBwMC55LCAwKSk7XHJcblxyXG5cdGZvcihpID0gMTsgaSA8PSBzZWdtZW50cyAtIDE7IGkrKykge1xyXG5cclxuXHRcdHZlcnRleCA9IFRIUkVFeC5NYXRoLnBvbGFyKGNlbnRlciwgTWF0aC5hYnMocmFkaXVzKSwgc3RhcnRBbmdsZSArIHRoZXRhQW5nbGUgKiBpKTtcclxuXHJcblx0XHR0aGlzLnZlcnRpY2VzLnB1c2gobmV3IFRIUkVFLlZlY3RvcjModmVydGV4LngsIHZlcnRleC55LCAwKSk7XHJcblxyXG5cdH1cclxuXHJcbn07XHJcblxyXG5USFJFRXguQnVsZ2VHZW9tZXRyeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5HZW9tZXRyeS5wcm90b3R5cGUgKTtcclxuICAgIFxyXG4vKipcclxuICogVmlld2VyIGNsYXNzIGZvciBhIGR4ZiBvYmplY3QuXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhIC0gdGhlIGR4ZiBvYmplY3RcclxuICogQHBhcmFtIHtPYmplY3R9IHBhcmVudCAtIHRoZSBwYXJlbnQgZWxlbWVudCB0byB3aGljaCB3ZSBhdHRhY2ggdGhlIHJlbmRlcmluZyBjYW52YXNcclxuICogQHBhcmFtIHtOdW1iZXJ9IHdpZHRoIC0gd2lkdGggb2YgdGhlIHJlbmRlcmluZyBjYW52YXMgaW4gcGl4ZWxzXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBoZWlnaHQgLSBoZWlnaHQgb2YgdGhlIHJlbmRlcmluZyBjYW52YXMgaW4gcGl4ZWxzXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBmb250IC0gYSBmb250IGxvYWRlZCB3aXRoIFRIUkVFLkZvbnRMb2FkZXIgXHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIFZpZXdlcihkYXRhLCBwYXJlbnQsIHdpZHRoLCBoZWlnaHQsIGZvbnQpIHtcclxuXHJcbiAgICBjcmVhdGVMaW5lVHlwZVNoYWRlcnMoZGF0YSk7XHJcblxyXG4gICAgdmFyIHNjZW5lID0gbmV3IFRIUkVFLlNjZW5lKCk7XHJcblxyXG4gICAgLy8gQ3JlYXRlIHNjZW5lIGZyb20gZHhmIG9iamVjdCAoZGF0YSlcclxuICAgIHZhciBpLCBlbnRpdHksIG9iaiwgbWluX3gsIG1pbl95LCBtaW5feiwgbWF4X3gsIG1heF95LCBtYXhfejtcclxuICAgIHZhciBkaW1zID0ge1xyXG4gICAgICAgIG1pbjogeyB4OiBmYWxzZSwgeTogZmFsc2UsIHo6IGZhbHNlfSxcclxuICAgICAgICBtYXg6IHsgeDogZmFsc2UsIHk6IGZhbHNlLCB6OiBmYWxzZX1cclxuICAgIH07XHJcbiAgICBmb3IoaSA9IDA7IGkgPCBkYXRhLmVudGl0aWVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgZW50aXR5ID0gZGF0YS5lbnRpdGllc1tpXTtcclxuXHJcbiAgICAgICAgaWYoZW50aXR5LnR5cGUgPT09ICdESU1FTlNJT04nKSB7XHJcbiAgICAgICAgICAgIGlmKGVudGl0eS5ibG9jaykge1xyXG4gICAgICAgICAgICAgICAgdmFyIGJsb2NrID0gZGF0YS5ibG9ja3NbZW50aXR5LmJsb2NrXTtcclxuICAgICAgICAgICAgICAgIGlmKCFibG9jaykge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ01pc3NpbmcgcmVmZXJlbmNlZCBibG9jayBcIicgKyBlbnRpdHkuYmxvY2sgKyAnXCInKTtcclxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGZvcih2YXIgaiA9IDA7IGogPCBibG9jay5lbnRpdGllcy5sZW5ndGg7IGorKykge1xyXG4gICAgICAgICAgICAgICAgICAgIG9iaiA9IGRyYXdFbnRpdHkoYmxvY2suZW50aXRpZXNbal0sIGRhdGEpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ1dBUk5JTkc6IE5vIGJsb2NrIGZvciBESU1FTlNJT04gZW50aXR5Jyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBvYmogPSBkcmF3RW50aXR5KGVudGl0eSwgZGF0YSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAob2JqKSB7XHJcbiAgICAgICAgICAgIHZhciBiYm94ID0gbmV3IFRIUkVFLkJveDMoKS5zZXRGcm9tT2JqZWN0KG9iaik7XHJcbiAgICAgICAgICAgIGlmIChiYm94Lm1pbi54ICYmICgoZGltcy5taW4ueCA9PT0gZmFsc2UpIHx8IChkaW1zLm1pbi54ID4gYmJveC5taW4ueCkpKSBkaW1zLm1pbi54ID0gYmJveC5taW4ueDtcclxuICAgICAgICAgICAgaWYgKGJib3gubWluLnkgJiYgKChkaW1zLm1pbi55ID09PSBmYWxzZSkgfHwgKGRpbXMubWluLnkgPiBiYm94Lm1pbi55KSkpIGRpbXMubWluLnkgPSBiYm94Lm1pbi55O1xyXG4gICAgICAgICAgICBpZiAoYmJveC5taW4ueiAmJiAoKGRpbXMubWluLnogPT09IGZhbHNlKSB8fCAoZGltcy5taW4ueiA+IGJib3gubWluLnopKSkgZGltcy5taW4ueiA9IGJib3gubWluLno7XHJcbiAgICAgICAgICAgIGlmIChiYm94Lm1heC54ICYmICgoZGltcy5tYXgueCA9PT0gZmFsc2UpIHx8IChkaW1zLm1heC54IDwgYmJveC5tYXgueCkpKSBkaW1zLm1heC54ID0gYmJveC5tYXgueDtcclxuICAgICAgICAgICAgaWYgKGJib3gubWF4LnkgJiYgKChkaW1zLm1heC55ID09PSBmYWxzZSkgfHwgKGRpbXMubWF4LnkgPCBiYm94Lm1heC55KSkpIGRpbXMubWF4LnkgPSBiYm94Lm1heC55O1xyXG4gICAgICAgICAgICBpZiAoYmJveC5tYXgueiAmJiAoKGRpbXMubWF4LnogPT09IGZhbHNlKSB8fCAoZGltcy5tYXgueiA8IGJib3gubWF4LnopKSkgZGltcy5tYXgueiA9IGJib3gubWF4Lno7XHJcbiAgICAgICAgICAgIHNjZW5lLmFkZChvYmopO1xyXG4gICAgICAgIH1cclxuICAgICAgICBvYmogPSBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIHdpZHRoID0gd2lkdGggfHwgcGFyZW50LmlubmVyV2lkdGg7XHJcbiAgICBoZWlnaHQgPSBoZWlnaHQgfHwgcGFyZW50LmlubmVySGVpZ2h0O1xyXG4gICAgdmFyIGFzcGVjdFJhdGlvID0gd2lkdGggLyBoZWlnaHQ7XHJcblxyXG4gICAgdmFyIHVwcGVyUmlnaHRDb3JuZXIgPSB7IHg6IGRpbXMubWF4LngsIHk6IGRpbXMubWF4LnkgfTtcclxuICAgIHZhciBsb3dlckxlZnRDb3JuZXIgPSB7IHg6IGRpbXMubWluLngsIHk6IGRpbXMubWluLnkgfTtcclxuXHJcbiAgICAvLyBGaWd1cmUgb3V0IHRoZSBjdXJyZW50IHZpZXdwb3J0IGV4dGVudHNcclxuICAgIHZhciB2cF93aWR0aCA9IHVwcGVyUmlnaHRDb3JuZXIueCAtIGxvd2VyTGVmdENvcm5lci54O1xyXG4gICAgdmFyIHZwX2hlaWdodCA9IHVwcGVyUmlnaHRDb3JuZXIueSAtIGxvd2VyTGVmdENvcm5lci55O1xyXG4gICAgdmFyIGNlbnRlciA9IGNlbnRlciB8fCB7XHJcbiAgICAgICAgeDogdnBfd2lkdGggLyAyICsgbG93ZXJMZWZ0Q29ybmVyLngsXHJcbiAgICAgICAgeTogdnBfaGVpZ2h0IC8gMiArIGxvd2VyTGVmdENvcm5lci55XHJcbiAgICB9O1xyXG5cclxuICAgIC8vIEZpdCBhbGwgb2JqZWN0cyBpbnRvIGN1cnJlbnQgVGhyZWVEWEYgdmlld2VyXHJcbiAgICB2YXIgZXh0ZW50c0FzcGVjdFJhdGlvID0gTWF0aC5hYnModnBfd2lkdGggLyB2cF9oZWlnaHQpO1xyXG4gICAgaWYgKGFzcGVjdFJhdGlvID4gZXh0ZW50c0FzcGVjdFJhdGlvKSB7XHJcbiAgICAgICAgdnBfd2lkdGggPSB2cF9oZWlnaHQgKiBhc3BlY3RSYXRpbztcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdnBfaGVpZ2h0ID0gdnBfd2lkdGggLyBhc3BlY3RSYXRpbztcclxuICAgIH1cclxuICAgIFxyXG4gICAgdmFyIHZpZXdQb3J0ID0ge1xyXG4gICAgICAgIGJvdHRvbTogLXZwX2hlaWdodCAvIDIsXHJcbiAgICAgICAgbGVmdDogLXZwX3dpZHRoIC8gMixcclxuICAgICAgICB0b3A6IHZwX2hlaWdodCAvIDIsXHJcbiAgICAgICAgcmlnaHQ6IHZwX3dpZHRoIC8gMixcclxuICAgICAgICBjZW50ZXI6IHtcclxuICAgICAgICAgICAgeDogY2VudGVyLngsXHJcbiAgICAgICAgICAgIHk6IGNlbnRlci55XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICB2YXIgY2FtZXJhID0gbmV3IFRIUkVFLk9ydGhvZ3JhcGhpY0NhbWVyYSh2aWV3UG9ydC5sZWZ0LCB2aWV3UG9ydC5yaWdodCwgdmlld1BvcnQudG9wLCB2aWV3UG9ydC5ib3R0b20sIDEsIDE5KTtcclxuICAgIGNhbWVyYS5wb3NpdGlvbi56ID0gMTA7XHJcbiAgICBjYW1lcmEucG9zaXRpb24ueCA9IHZpZXdQb3J0LmNlbnRlci54O1xyXG4gICAgY2FtZXJhLnBvc2l0aW9uLnkgPSB2aWV3UG9ydC5jZW50ZXIueTtcclxuXHJcbiAgICB2YXIgcmVuZGVyZXIgPSB0aGlzLnJlbmRlcmVyID0gbmV3IFRIUkVFLldlYkdMUmVuZGVyZXIoKTtcclxuICAgIHJlbmRlcmVyLnNldFNpemUod2lkdGgsIGhlaWdodCk7XHJcbiAgICByZW5kZXJlci5zZXRDbGVhckNvbG9yKDB4ZmZmZmZmZiwgMSk7XHJcblxyXG4gICAgcGFyZW50LmFwcGVuZENoaWxkKHJlbmRlcmVyLmRvbUVsZW1lbnQpO1xyXG4gICAgcGFyZW50LnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xyXG5cclxuICAgIC8vVE9ETzogTmVlZCB0byBtYWtlIHRoaXMgYW4gb3B0aW9uIHNvbWVob3cgc28gb3RoZXJzIGNhbiByb2xsIHRoZWlyIG93biBjb250cm9scy5cclxuICAgIHZhciBjb250cm9scyA9IG5ldyBPcmJpdENvbnRyb2xzKGNhbWVyYSwgcGFyZW50KTtcclxuICAgIGNvbnRyb2xzLnRhcmdldC54ID0gY2FtZXJhLnBvc2l0aW9uLng7XHJcbiAgICBjb250cm9scy50YXJnZXQueSA9IGNhbWVyYS5wb3NpdGlvbi55O1xyXG4gICAgY29udHJvbHMudGFyZ2V0LnogPSAwO1xyXG4gICAgY29udHJvbHMuem9vbVNwZWVkID0gMztcclxuXHJcbiAgICAvL1VuY29tbWVudCB0aGlzIHRvIGRpc2FibGUgcm90YXRpb24gKGRvZXMgbm90IG1ha2UgbXVjaCBzZW5zZSB3aXRoIDJEIGRyYXdpbmdzKS5cclxuICAgIC8vY29udHJvbHMuZW5hYmxlUm90YXRlID0gZmFsc2U7XHJcblxyXG4gICAgdGhpcy5yZW5kZXIgPSBmdW5jdGlvbigpIHsgcmVuZGVyZXIucmVuZGVyKHNjZW5lLCBjYW1lcmEpIH07XHJcbiAgICBjb250cm9scy5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCB0aGlzLnJlbmRlcik7XHJcbiAgICB0aGlzLnJlbmRlcigpO1xyXG4gICAgY29udHJvbHMudXBkYXRlKCk7XHJcblxyXG4gICAgdGhpcy5yZXNpemUgPSBmdW5jdGlvbih3aWR0aCwgaGVpZ2h0KSB7XHJcbiAgICAgICAgdmFyIG9yaWdpbmFsV2lkdGggPSByZW5kZXJlci5kb21FbGVtZW50LndpZHRoO1xyXG4gICAgICAgIHZhciBvcmlnaW5hbEhlaWdodCA9IHJlbmRlcmVyLmRvbUVsZW1lbnQuaGVpZ2h0O1xyXG5cclxuICAgICAgICB2YXIgaHNjYWxlID0gd2lkdGggLyBvcmlnaW5hbFdpZHRoO1xyXG4gICAgICAgIHZhciB2c2NhbGUgPSBoZWlnaHQgLyBvcmlnaW5hbEhlaWdodDtcclxuXHJcblxyXG4gICAgICAgIGNhbWVyYS50b3AgPSAodnNjYWxlICogY2FtZXJhLnRvcCk7XHJcbiAgICAgICAgY2FtZXJhLmJvdHRvbSA9ICh2c2NhbGUgKiBjYW1lcmEuYm90dG9tKTtcclxuICAgICAgICBjYW1lcmEubGVmdCA9IChoc2NhbGUgKiBjYW1lcmEubGVmdCk7XHJcbiAgICAgICAgY2FtZXJhLnJpZ2h0ID0gKGhzY2FsZSAqIGNhbWVyYS5yaWdodCk7XHJcblxyXG4vLyAgICAgICAgY2FtZXJhLnVwZGF0ZVByb2plY3Rpb25NYXRyaXgoKTtcclxuXHJcbiAgICAgICAgcmVuZGVyZXIuc2V0U2l6ZSh3aWR0aCwgaGVpZ2h0KTtcclxuICAgICAgICByZW5kZXJlci5zZXRDbGVhckNvbG9yKDB4ZmZmZmZmZiwgMSk7XHJcbiAgICAgICAgdGhpcy5yZW5kZXIoKTtcclxuICAgIH07XHJcblxyXG4gICAgZnVuY3Rpb24gZHJhd0VudGl0eShlbnRpdHksIGRhdGEpIHtcclxuICAgICAgICB2YXIgbWVzaDtcclxuICAgICAgICBpZihlbnRpdHkudHlwZSA9PT0gJ0NJUkNMRScgfHwgZW50aXR5LnR5cGUgPT09ICdBUkMnKSB7XHJcbiAgICAgICAgICAgIG1lc2ggPSBkcmF3QXJjKGVudGl0eSwgZGF0YSk7XHJcbiAgICAgICAgfSBlbHNlIGlmKGVudGl0eS50eXBlID09PSAnTFdQT0xZTElORScgfHwgZW50aXR5LnR5cGUgPT09ICdMSU5FJyB8fCBlbnRpdHkudHlwZSA9PT0gJ1BPTFlMSU5FJykge1xyXG4gICAgICAgICAgICBtZXNoID0gZHJhd0xpbmUoZW50aXR5LCBkYXRhKTtcclxuICAgICAgICB9IGVsc2UgaWYoZW50aXR5LnR5cGUgPT09ICdURVhUJykge1xyXG4gICAgICAgICAgICBtZXNoID0gZHJhd1RleHQoZW50aXR5LCBkYXRhKTtcclxuICAgICAgICB9IGVsc2UgaWYoZW50aXR5LnR5cGUgPT09ICdTT0xJRCcpIHtcclxuICAgICAgICAgICAgbWVzaCA9IGRyYXdTb2xpZChlbnRpdHksIGRhdGEpO1xyXG4gICAgICAgIH0gZWxzZSBpZihlbnRpdHkudHlwZSA9PT0gJ1BPSU5UJykge1xyXG4gICAgICAgICAgICBtZXNoID0gZHJhd1BvaW50KGVudGl0eSwgZGF0YSk7XHJcbiAgICAgICAgfSBlbHNlIGlmKGVudGl0eS50eXBlID09PSAnSU5TRVJUJykge1xyXG4gICAgICAgICAgICBtZXNoID0gZHJhd0Jsb2NrKGVudGl0eSwgZGF0YSk7XHJcbiAgICAgICAgfSBlbHNlIGlmKGVudGl0eS50eXBlID09PSAnU1BMSU5FJykge1xyXG4gICAgICAgICAgICBtZXNoID0gZHJhd1NwbGluZShlbnRpdHksIGRhdGEpO1xyXG4gICAgICAgIH0gZWxzZSBpZihlbnRpdHkudHlwZSA9PT0gJ01URVhUJykge1xyXG4gICAgICAgICAgICBtZXNoID0gZHJhd010ZXh0KGVudGl0eSwgZGF0YSk7XHJcbiAgICAgICAgfSBlbHNlIGlmKGVudGl0eS50eXBlID09PSAnRUxMSVBTRScpIHtcclxuICAgICAgICAgICAgbWVzaCA9IGRyYXdFbGxpcHNlKGVudGl0eSwgZGF0YSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIlVuc3VwcG9ydGVkIEVudGl0eSBUeXBlOiBcIiArIGVudGl0eS50eXBlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG1lc2g7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZHJhd0VsbGlwc2UoZW50aXR5LCBkYXRhKSB7XHJcbiAgICAgICAgdmFyIGNvbG9yID0gZ2V0Q29sb3IoZW50aXR5LCBkYXRhKTtcclxuXHJcbiAgICAgICAgdmFyIHhyYWQgPSBNYXRoLnNxcnQoTWF0aC5wb3coZW50aXR5Lm1ham9yQXhpc0VuZFBvaW50LngsMikgKyBNYXRoLnBvdyhlbnRpdHkubWFqb3JBeGlzRW5kUG9pbnQueSwyKSk7XHJcbiAgICAgICAgdmFyIHlyYWQgPSB4cmFkKmVudGl0eS5heGlzUmF0aW87XHJcbiAgICAgICAgdmFyIHJvdGF0aW9uID0gTWF0aC5hdGFuMihlbnRpdHkubWFqb3JBeGlzRW5kUG9pbnQueSwgZW50aXR5Lm1ham9yQXhpc0VuZFBvaW50LngpO1xyXG5cclxuICAgICAgICB2YXIgY3VydmUgPSBuZXcgVEhSRUUuRWxsaXBzZUN1cnZlKFxyXG4gICAgICAgICAgICBlbnRpdHkuY2VudGVyLngsICBlbnRpdHkuY2VudGVyLnksXHJcbiAgICAgICAgICAgIHhyYWQsIHlyYWQsXHJcbiAgICAgICAgICAgIGVudGl0eS5zdGFydEFuZ2xlLCBlbnRpdHkuZW5kQW5nbGUsXHJcbiAgICAgICAgICAgIGZhbHNlLCAvLyBBbHdheXMgY291bnRlcmNsb2Nrd2lzZVxyXG4gICAgICAgICAgICByb3RhdGlvblxyXG4gICAgICAgICk7XHJcblxyXG4gICAgICAgIHZhciBwb2ludHMgPSBjdXJ2ZS5nZXRQb2ludHMoIDUwICk7XHJcbiAgICAgICAgdmFyIGdlb21ldHJ5ID0gbmV3IFRIUkVFLkJ1ZmZlckdlb21ldHJ5KCkuc2V0RnJvbVBvaW50cyggcG9pbnRzICk7XHJcbiAgICAgICAgdmFyIG1hdGVyaWFsID0gbmV3IFRIUkVFLkxpbmVCYXNpY01hdGVyaWFsKCB7ICBsaW5ld2lkdGg6IDEsIGNvbG9yIDogY29sb3IgfSApO1xyXG5cclxuICAgICAgICAvLyBDcmVhdGUgdGhlIGZpbmFsIG9iamVjdCB0byBhZGQgdG8gdGhlIHNjZW5lXHJcbiAgICAgICAgdmFyIGVsbGlwc2UgPSBuZXcgVEhSRUUuTGluZSggZ2VvbWV0cnksIG1hdGVyaWFsICk7XHJcbiAgICAgICAgcmV0dXJuIGVsbGlwc2U7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZHJhd010ZXh0KGVudGl0eSwgZGF0YSkge1xyXG4gICAgICAgIHZhciBjb2xvciA9IGdldENvbG9yKGVudGl0eSwgZGF0YSk7XHJcblxyXG4gICAgICAgIHZhciBnZW9tZXRyeSA9IG5ldyBUSFJFRS5UZXh0R2VvbWV0cnkoIGVudGl0eS50ZXh0LCB7XHJcbiAgICAgICAgICAgIGZvbnQ6IGZvbnQsXHJcbiAgICAgICAgICAgIHNpemU6IGVudGl0eS5oZWlnaHQgKiAoNC81KSxcclxuICAgICAgICAgICAgaGVpZ2h0OiAxXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdmFyIG1hdGVyaWFsID0gbmV3IFRIUkVFLk1lc2hCYXNpY01hdGVyaWFsKCB7Y29sb3I6IGNvbG9yfSApO1xyXG4gICAgICAgIHZhciB0ZXh0ID0gbmV3IFRIUkVFLk1lc2goIGdlb21ldHJ5LCBtYXRlcmlhbCApO1xyXG5cclxuICAgICAgICAvLyBNZWFzdXJlIHdoYXQgd2UgcmVuZGVyZWQuXHJcbiAgICAgICAgdmFyIG1lYXN1cmUgPSBuZXcgVEhSRUUuQm94MygpO1xyXG4gICAgICAgIG1lYXN1cmUuc2V0RnJvbU9iamVjdCggdGV4dCApO1xyXG5cclxuICAgICAgICB2YXIgdGV4dFdpZHRoICA9IG1lYXN1cmUubWF4LnggLSBtZWFzdXJlLm1pbi54O1xyXG5cclxuICAgICAgICAvLyBJZiB0aGUgdGV4dCBlbmRzIHVwIGJlaW5nIHdpZGVyIHRoYW4gdGhlIGJveCwgaXQncyBzdXBwb3NlZFxyXG4gICAgICAgIC8vIHRvIGJlIG11bHRpbGluZS4gRG9pbmcgdGhhdCBpbiB0aHJlZUpTIGlzIG92ZXJraWxsLlxyXG4gICAgICAgIGlmICh0ZXh0V2lkdGggPiBlbnRpdHkud2lkdGgpIHtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coXCJDYW4ndCByZW5kZXIgdGhpcyBtdWx0aXBsaW5lIE1URVhUIGVudGl0eSwgc29ycnkuXCIsIGVudGl0eSk7XHJcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0ZXh0LnBvc2l0aW9uLnogPSAwO1xyXG4gICAgICAgIHN3aXRjaCAoZW50aXR5LmF0dGFjaG1lbnRQb2ludCkge1xyXG4gICAgICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICAgICAgICAvLyBUb3AgTGVmdFxyXG4gICAgICAgICAgICAgICAgdGV4dC5wb3NpdGlvbi54ID0gZW50aXR5LnBvc2l0aW9uLng7XHJcbiAgICAgICAgICAgICAgICB0ZXh0LnBvc2l0aW9uLnkgPSBlbnRpdHkucG9zaXRpb24ueSAtIGVudGl0eS5oZWlnaHQ7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIDI6XHJcbiAgICAgICAgICAgICAgICAvLyBUb3AgQ2VudGVyXHJcbiAgICAgICAgICAgICAgICB0ZXh0LnBvc2l0aW9uLnggPSBlbnRpdHkucG9zaXRpb24ueCAtIHRleHRXaWR0aC8yO1xyXG4gICAgICAgICAgICAgICAgdGV4dC5wb3NpdGlvbi55ID0gZW50aXR5LnBvc2l0aW9uLnkgLSBlbnRpdHkuaGVpZ2h0O1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAzOlxyXG4gICAgICAgICAgICAgICAgLy8gVG9wIFJpZ2h0XHJcbiAgICAgICAgICAgICAgICB0ZXh0LnBvc2l0aW9uLnggPSBlbnRpdHkucG9zaXRpb24ueCAtIHRleHRXaWR0aDtcclxuICAgICAgICAgICAgICAgIHRleHQucG9zaXRpb24ueSA9IGVudGl0eS5wb3NpdGlvbi55IC0gZW50aXR5LmhlaWdodDtcclxuICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICBjYXNlIDQ6XHJcbiAgICAgICAgICAgICAgICAvLyBNaWRkbGUgTGVmdFxyXG4gICAgICAgICAgICAgICAgdGV4dC5wb3NpdGlvbi54ID0gZW50aXR5LnBvc2l0aW9uLng7XHJcbiAgICAgICAgICAgICAgICB0ZXh0LnBvc2l0aW9uLnkgPSBlbnRpdHkucG9zaXRpb24ueSAtIGVudGl0eS5oZWlnaHQvMjtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgNTpcclxuICAgICAgICAgICAgICAgIC8vIE1pZGRsZSBDZW50ZXJcclxuICAgICAgICAgICAgICAgIHRleHQucG9zaXRpb24ueCA9IGVudGl0eS5wb3NpdGlvbi54IC0gdGV4dFdpZHRoLzI7XHJcbiAgICAgICAgICAgICAgICB0ZXh0LnBvc2l0aW9uLnkgPSBlbnRpdHkucG9zaXRpb24ueSAtIGVudGl0eS5oZWlnaHQvMjtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgNjpcclxuICAgICAgICAgICAgICAgIC8vIE1pZGRsZSBSaWdodFxyXG4gICAgICAgICAgICAgICAgdGV4dC5wb3NpdGlvbi54ID0gZW50aXR5LnBvc2l0aW9uLnggLSB0ZXh0V2lkdGg7XHJcbiAgICAgICAgICAgICAgICB0ZXh0LnBvc2l0aW9uLnkgPSBlbnRpdHkucG9zaXRpb24ueSAtIGVudGl0eS5oZWlnaHQvMjtcclxuICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICBjYXNlIDc6XHJcbiAgICAgICAgICAgICAgICAvLyBCb3R0b20gTGVmdFxyXG4gICAgICAgICAgICAgICAgdGV4dC5wb3NpdGlvbi54ID0gZW50aXR5LnBvc2l0aW9uLng7XHJcbiAgICAgICAgICAgICAgICB0ZXh0LnBvc2l0aW9uLnkgPSBlbnRpdHkucG9zaXRpb24ueTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgODpcclxuICAgICAgICAgICAgICAgIC8vIEJvdHRvbSBDZW50ZXJcclxuICAgICAgICAgICAgICAgIHRleHQucG9zaXRpb24ueCA9IGVudGl0eS5wb3NpdGlvbi54IC0gdGV4dFdpZHRoLzI7XHJcbiAgICAgICAgICAgICAgICB0ZXh0LnBvc2l0aW9uLnkgPSBlbnRpdHkucG9zaXRpb24ueTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgOTpcclxuICAgICAgICAgICAgICAgIC8vIEJvdHRvbSBSaWdodFxyXG4gICAgICAgICAgICAgICAgdGV4dC5wb3NpdGlvbi54ID0gZW50aXR5LnBvc2l0aW9uLnggLSB0ZXh0V2lkdGg7XHJcbiAgICAgICAgICAgICAgICB0ZXh0LnBvc2l0aW9uLnkgPSBlbnRpdHkucG9zaXRpb24ueTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICByZXR1cm4gdGV4dDtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBkcmF3U3BsaW5lKGVudGl0eSwgZGF0YSkge1xyXG4gICAgICAgIHZhciBjb2xvciA9IGdldENvbG9yKGVudGl0eSwgZGF0YSk7XHJcblxyXG4gICAgICAgIHZhciBwb2ludHMgPSBlbnRpdHkuY29udHJvbFBvaW50cy5tYXAoZnVuY3Rpb24odmVjKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgVEhSRUUuVmVjdG9yMih2ZWMueCwgdmVjLnkpO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICB2YXIgaW50ZXJwb2xhdGVkUG9pbnRzID0gW107XHJcbiAgICAgICAgaWYgKGVudGl0eS5kZWdyZWVPZlNwbGluZUN1cnZlID09PSAyIHx8IGVudGl0eS5kZWdyZWVPZlNwbGluZUN1cnZlID09PSAzKSB7XHJcbiAgICAgICAgICAgIGZvcih2YXIgaSA9IDA7IGkgKyAyIDwgcG9pbnRzLmxlbmd0aDsgaSA9IGkgKyAyKSB7XHJcbiAgICAgICAgaWYgKGVudGl0eS5kZWdyZWVPZlNwbGluZUN1cnZlID09PSAyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnZlID0gbmV3IFRIUkVFLlF1YWRyYXRpY0JlemllckN1cnZlKHBvaW50c1tpXSwgcG9pbnRzW2kgKyAxXSwgcG9pbnRzW2kgKyAyXSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgY3VydmUgPSBuZXcgVEhSRUUuUXVhZHJhdGljQmV6aWVyQ3VydmUzKHBvaW50c1tpXSwgcG9pbnRzW2kgKyAxXSwgcG9pbnRzW2kgKyAyXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaW50ZXJwb2xhdGVkUG9pbnRzLnB1c2guYXBwbHkoaW50ZXJwb2xhdGVkUG9pbnRzLCBjdXJ2ZS5nZXRQb2ludHMoNTApKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGN1cnZlID0gbmV3IFRIUkVFLlNwbGluZUN1cnZlKHBvaW50cyk7XHJcbiAgICAgICAgICAgIGludGVycG9sYXRlZFBvaW50cyA9IGN1cnZlLmdldFBvaW50cyggMTAwICk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgZ2VvbWV0cnkgPSBuZXcgVEhSRUUuQnVmZmVyR2VvbWV0cnkoKS5zZXRGcm9tUG9pbnRzKCBpbnRlcnBvbGF0ZWRQb2ludHMgKTtcclxuICAgICAgICB2YXIgbWF0ZXJpYWwgPSBuZXcgVEhSRUUuTGluZUJhc2ljTWF0ZXJpYWwoIHsgbGluZXdpZHRoOiAxLCBjb2xvciA6IGNvbG9yIH0gKTtcclxuICAgICAgICB2YXIgc3BsaW5lT2JqZWN0ID0gbmV3IFRIUkVFLkxpbmUoIGdlb21ldHJ5LCBtYXRlcmlhbCApO1xyXG5cclxuICAgICAgICByZXR1cm4gc3BsaW5lT2JqZWN0O1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGRyYXdMaW5lKGVudGl0eSwgZGF0YSkge1xyXG4gICAgICAgIHZhciBnZW9tZXRyeSA9IG5ldyBUSFJFRS5HZW9tZXRyeSgpLFxyXG4gICAgICAgICAgICBjb2xvciA9IGdldENvbG9yKGVudGl0eSwgZGF0YSksXHJcbiAgICAgICAgICAgIG1hdGVyaWFsLCBsaW5lVHlwZSwgdmVydGV4LCBzdGFydFBvaW50LCBlbmRQb2ludCwgYnVsZ2VHZW9tZXRyeSxcclxuICAgICAgICAgICAgYnVsZ2UsIGksIGxpbmU7XHJcblxyXG4gICAgICAgIC8vIGNyZWF0ZSBnZW9tZXRyeVxyXG4gICAgICAgIGZvcihpID0gMDsgaSA8IGVudGl0eS52ZXJ0aWNlcy5sZW5ndGg7IGkrKykge1xyXG5cclxuICAgICAgICAgICAgaWYoZW50aXR5LnZlcnRpY2VzW2ldLmJ1bGdlKSB7XHJcbiAgICAgICAgICAgICAgICBidWxnZSA9IGVudGl0eS52ZXJ0aWNlc1tpXS5idWxnZTtcclxuICAgICAgICAgICAgICAgIHN0YXJ0UG9pbnQgPSBlbnRpdHkudmVydGljZXNbaV07XHJcbiAgICAgICAgICAgICAgICBlbmRQb2ludCA9IGkgKyAxIDwgZW50aXR5LnZlcnRpY2VzLmxlbmd0aCA/IGVudGl0eS52ZXJ0aWNlc1tpICsgMV0gOiBnZW9tZXRyeS52ZXJ0aWNlc1swXTtcclxuXHJcbiAgICAgICAgICAgICAgICBidWxnZUdlb21ldHJ5ID0gbmV3IFRIUkVFeC5CdWxnZUdlb21ldHJ5KHN0YXJ0UG9pbnQsIGVuZFBvaW50LCBidWxnZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgZ2VvbWV0cnkudmVydGljZXMucHVzaC5hcHBseShnZW9tZXRyeS52ZXJ0aWNlcywgYnVsZ2VHZW9tZXRyeS52ZXJ0aWNlcyk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB2ZXJ0ZXggPSBlbnRpdHkudmVydGljZXNbaV07XHJcbiAgICAgICAgICAgICAgICBnZW9tZXRyeS52ZXJ0aWNlcy5wdXNoKG5ldyBUSFJFRS5WZWN0b3IzKHZlcnRleC54LCB2ZXJ0ZXgueSwgMCkpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH1cclxuICAgICAgICBpZihlbnRpdHkuc2hhcGUpIGdlb21ldHJ5LnZlcnRpY2VzLnB1c2goZ2VvbWV0cnkudmVydGljZXNbMF0pO1xyXG5cclxuXHJcbiAgICAgICAgLy8gc2V0IG1hdGVyaWFsXHJcbiAgICAgICAgaWYoZW50aXR5LmxpbmVUeXBlKSB7XHJcbiAgICAgICAgICAgIGxpbmVUeXBlID0gZGF0YS50YWJsZXMubGluZVR5cGUubGluZVR5cGVzW2VudGl0eS5saW5lVHlwZV07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZihsaW5lVHlwZSAmJiBsaW5lVHlwZS5wYXR0ZXJuICYmIGxpbmVUeXBlLnBhdHRlcm4ubGVuZ3RoICE9PSAwKSB7XHJcbiAgICAgICAgICAgIG1hdGVyaWFsID0gbmV3IFRIUkVFLkxpbmVEYXNoZWRNYXRlcmlhbCh7IGNvbG9yOiBjb2xvciwgZ2FwU2l6ZTogNCwgZGFzaFNpemU6IDR9KTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBtYXRlcmlhbCA9IG5ldyBUSFJFRS5MaW5lQmFzaWNNYXRlcmlhbCh7IGxpbmV3aWR0aDogMSwgY29sb3I6IGNvbG9yIH0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gaWYobGluZVR5cGUgJiYgbGluZVR5cGUucGF0dGVybiAmJiBsaW5lVHlwZS5wYXR0ZXJuLmxlbmd0aCAhPT0gMCkge1xyXG5cclxuICAgICAgICAvLyAgICAgICAgICAgZ2VvbWV0cnkuY29tcHV0ZUxpbmVEaXN0YW5jZXMoKTtcclxuXHJcbiAgICAgICAgLy8gICAgICAgICAgIC8vIFVnbHkgaGFjayB0byBhZGQgZGlmZnVzZSB0byB0aGlzLiBNYXliZSBjb3B5IHRoZSB1bmlmb3JtcyBvYmplY3Qgc28gd2VcclxuICAgICAgICAvLyAgICAgICAgICAgLy8gZG9uJ3QgYWRkIGRpZmZ1c2UgdG8gYSBtYXRlcmlhbC5cclxuICAgICAgICAvLyAgICAgICAgICAgbGluZVR5cGUubWF0ZXJpYWwudW5pZm9ybXMuZGlmZnVzZSA9IHsgdHlwZTogJ2MnLCB2YWx1ZTogbmV3IFRIUkVFLkNvbG9yKGNvbG9yKSB9O1xyXG5cclxuICAgICAgICAvLyBcdG1hdGVyaWFsID0gbmV3IFRIUkVFLlNoYWRlck1hdGVyaWFsKHtcclxuICAgICAgICAvLyBcdFx0dW5pZm9ybXM6IGxpbmVUeXBlLm1hdGVyaWFsLnVuaWZvcm1zLFxyXG4gICAgICAgIC8vIFx0XHR2ZXJ0ZXhTaGFkZXI6IGxpbmVUeXBlLm1hdGVyaWFsLnZlcnRleFNoYWRlcixcclxuICAgICAgICAvLyBcdFx0ZnJhZ21lbnRTaGFkZXI6IGxpbmVUeXBlLm1hdGVyaWFsLmZyYWdtZW50U2hhZGVyXHJcbiAgICAgICAgLy8gXHR9KTtcclxuICAgICAgICAvLyB9ZWxzZSB7XHJcbiAgICAgICAgLy8gXHRtYXRlcmlhbCA9IG5ldyBUSFJFRS5MaW5lQmFzaWNNYXRlcmlhbCh7IGxpbmV3aWR0aDogMSwgY29sb3I6IGNvbG9yIH0pO1xyXG4gICAgICAgIC8vIH1cclxuXHJcbiAgICAgICAgbGluZSA9IG5ldyBUSFJFRS5MaW5lKGdlb21ldHJ5LCBtYXRlcmlhbCk7XHJcbiAgICAgICAgcmV0dXJuIGxpbmU7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIGZ1bmN0aW9uIGRyYXdBcmMoZW50aXR5LCBkYXRhKSB7XHJcbiAgICAgICAgaWYgKGVudGl0eS50eXBlID09PSAnQ0lSQ0xFJykge1xyXG4gICAgICAgICAgICBzdGFydEFuZ2xlID0gZW50aXR5LnN0YXJ0QW5nbGUgfHwgMDtcclxuICAgICAgICAgICAgZW5kQW5nbGUgPSBzdGFydEFuZ2xlICsgMiAqIE1hdGguUEk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgc3RhcnRBbmdsZSA9IGVudGl0eS5zdGFydEFuZ2xlO1xyXG4gICAgICAgICAgICBlbmRBbmdsZSA9IGVudGl0eS5lbmRBbmdsZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBjdXJ2ZSA9IG5ldyBUSFJFRS5BcmNDdXJ2ZShcclxuICAgICAgICAgICAgMCwgMCxcclxuICAgICAgICAgICAgZW50aXR5LnJhZGl1cyxcclxuICAgICAgICAgICAgc3RhcnRBbmdsZSxcclxuICAgICAgICAgICAgZW5kQW5nbGUpO1xyXG5cclxuICAgICAgICB2YXIgcG9pbnRzID0gY3VydmUuZ2V0UG9pbnRzKCAzMiApO1xyXG4gICAgICAgIHZhciBnZW9tZXRyeSA9IG5ldyBUSFJFRS5CdWZmZXJHZW9tZXRyeSgpLnNldEZyb21Qb2ludHMoIHBvaW50cyApO1xyXG5cclxuICAgICAgICB2YXIgbWF0ZXJpYWwgPSBuZXcgVEhSRUUuTGluZUJhc2ljTWF0ZXJpYWwoeyBjb2xvcjogZ2V0Q29sb3IoZW50aXR5LCBkYXRhKSB9KTtcclxuXHJcbiAgICAgICAgdmFyIGFyYyA9IG5ldyBUSFJFRS5MaW5lKGdlb21ldHJ5LCBtYXRlcmlhbCk7XHJcbiAgICAgICAgYXJjLnBvc2l0aW9uLnggPSBlbnRpdHkuY2VudGVyLng7XHJcbiAgICAgICAgYXJjLnBvc2l0aW9uLnkgPSBlbnRpdHkuY2VudGVyLnk7XHJcbiAgICAgICAgYXJjLnBvc2l0aW9uLnogPSBlbnRpdHkuY2VudGVyLno7XHJcblxyXG4gICAgICAgIHJldHVybiBhcmM7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZHJhd1NvbGlkKGVudGl0eSwgZGF0YSkge1xyXG4gICAgICAgIHZhciBtYXRlcmlhbCwgbWVzaCwgdmVydHMsXHJcbiAgICAgICAgICAgIGdlb21ldHJ5ID0gbmV3IFRIUkVFLkdlb21ldHJ5KCk7XHJcblxyXG4gICAgICAgIHZlcnRzID0gZ2VvbWV0cnkudmVydGljZXM7XHJcbiAgICAgICAgdmVydHMucHVzaChuZXcgVEhSRUUuVmVjdG9yMyhlbnRpdHkucG9pbnRzWzBdLngsIGVudGl0eS5wb2ludHNbMF0ueSwgZW50aXR5LnBvaW50c1swXS56KSk7XHJcbiAgICAgICAgdmVydHMucHVzaChuZXcgVEhSRUUuVmVjdG9yMyhlbnRpdHkucG9pbnRzWzFdLngsIGVudGl0eS5wb2ludHNbMV0ueSwgZW50aXR5LnBvaW50c1sxXS56KSk7XHJcbiAgICAgICAgdmVydHMucHVzaChuZXcgVEhSRUUuVmVjdG9yMyhlbnRpdHkucG9pbnRzWzJdLngsIGVudGl0eS5wb2ludHNbMl0ueSwgZW50aXR5LnBvaW50c1syXS56KSk7XHJcbiAgICAgICAgdmVydHMucHVzaChuZXcgVEhSRUUuVmVjdG9yMyhlbnRpdHkucG9pbnRzWzNdLngsIGVudGl0eS5wb2ludHNbM10ueSwgZW50aXR5LnBvaW50c1szXS56KSk7XHJcblxyXG4gICAgICAgIC8vIENhbGN1bGF0ZSB3aGljaCBkaXJlY3Rpb24gdGhlIHBvaW50cyBhcmUgZmFjaW5nIChjbG9ja3dpc2Ugb3IgY291bnRlci1jbG9ja3dpc2UpXHJcbiAgICAgICAgdmFyIHZlY3RvcjEgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG4gICAgICAgIHZhciB2ZWN0b3IyID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuICAgICAgICB2ZWN0b3IxLnN1YlZlY3RvcnModmVydHNbMV0sIHZlcnRzWzBdKTtcclxuICAgICAgICB2ZWN0b3IyLnN1YlZlY3RvcnModmVydHNbMl0sIHZlcnRzWzBdKTtcclxuICAgICAgICB2ZWN0b3IxLmNyb3NzKHZlY3RvcjIpO1xyXG5cclxuICAgICAgICAvLyBJZiB6IDwgMCB0aGVuIHdlIG11c3QgZHJhdyB0aGVzZSBpbiByZXZlcnNlIG9yZGVyXHJcbiAgICAgICAgaWYodmVjdG9yMS56IDwgMCkge1xyXG4gICAgICAgICAgICBnZW9tZXRyeS5mYWNlcy5wdXNoKG5ldyBUSFJFRS5GYWNlMygyLCAxLCAwKSk7XHJcbiAgICAgICAgICAgIGdlb21ldHJ5LmZhY2VzLnB1c2gobmV3IFRIUkVFLkZhY2UzKDIsIDMsIDEpKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBnZW9tZXRyeS5mYWNlcy5wdXNoKG5ldyBUSFJFRS5GYWNlMygwLCAxLCAyKSk7XHJcbiAgICAgICAgICAgIGdlb21ldHJ5LmZhY2VzLnB1c2gobmV3IFRIUkVFLkZhY2UzKDEsIDMsIDIpKTtcclxuICAgICAgICB9XHJcblxyXG5cclxuICAgICAgICBtYXRlcmlhbCA9IG5ldyBUSFJFRS5NZXNoQmFzaWNNYXRlcmlhbCh7IGNvbG9yOiBnZXRDb2xvcihlbnRpdHksIGRhdGEpIH0pO1xyXG5cclxuICAgICAgICByZXR1cm4gbmV3IFRIUkVFLk1lc2goZ2VvbWV0cnksIG1hdGVyaWFsKTtcclxuICAgICAgICBcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBkcmF3VGV4dChlbnRpdHksIGRhdGEpIHtcclxuICAgICAgICB2YXIgZ2VvbWV0cnksIG1hdGVyaWFsLCB0ZXh0O1xyXG5cclxuICAgICAgICBpZighZm9udClcclxuICAgICAgICAgICAgcmV0dXJuIGNvbnNvbGUud2FybignVGV4dCBpcyBub3Qgc3VwcG9ydGVkIHdpdGhvdXQgYSBUaHJlZS5qcyBmb250IGxvYWRlZCB3aXRoIFRIUkVFLkZvbnRMb2FkZXIhIExvYWQgYSBmb250IG9mIHlvdXIgY2hvaWNlIGFuZCBwYXNzIHRoaXMgaW50byB0aGUgY29uc3RydWN0b3IuIFNlZSB0aGUgc2FtcGxlIGZvciB0aGlzIHJlcG9zaXRvcnkgb3IgVGhyZWUuanMgZXhhbXBsZXMgYXQgaHR0cDovL3RocmVlanMub3JnL2V4YW1wbGVzLz9xPXRleHQjd2ViZ2xfZ2VvbWV0cnlfdGV4dCBmb3IgbW9yZSBkZXRhaWxzLicpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIGdlb21ldHJ5ID0gbmV3IFRIUkVFLlRleHRHZW9tZXRyeShlbnRpdHkudGV4dCwgeyBmb250OiBmb250LCBoZWlnaHQ6IDAsIHNpemU6IGVudGl0eS50ZXh0SGVpZ2h0IHx8IDEyIH0pO1xyXG5cclxuICAgICAgICBtYXRlcmlhbCA9IG5ldyBUSFJFRS5NZXNoQmFzaWNNYXRlcmlhbCh7IGNvbG9yOiBnZXRDb2xvcihlbnRpdHksIGRhdGEpIH0pO1xyXG5cclxuICAgICAgICB0ZXh0ID0gbmV3IFRIUkVFLk1lc2goZ2VvbWV0cnksIG1hdGVyaWFsKTtcclxuICAgICAgICB0ZXh0LnBvc2l0aW9uLnggPSBlbnRpdHkuc3RhcnRQb2ludC54O1xyXG4gICAgICAgIHRleHQucG9zaXRpb24ueSA9IGVudGl0eS5zdGFydFBvaW50Lnk7XHJcbiAgICAgICAgdGV4dC5wb3NpdGlvbi56ID0gZW50aXR5LnN0YXJ0UG9pbnQuejtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRleHQ7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZHJhd1BvaW50KGVudGl0eSwgZGF0YSkge1xyXG4gICAgICAgIHZhciBnZW9tZXRyeSwgbWF0ZXJpYWwsIHBvaW50O1xyXG5cclxuICAgICAgICBnZW9tZXRyeSA9IG5ldyBUSFJFRS5HZW9tZXRyeSgpO1xyXG5cclxuICAgICAgICBnZW9tZXRyeS52ZXJ0aWNlcy5wdXNoKG5ldyBUSFJFRS5WZWN0b3IzKGVudGl0eS5wb3NpdGlvbi54LCBlbnRpdHkucG9zaXRpb24ueSwgZW50aXR5LnBvc2l0aW9uLnopKTtcclxuXHJcbiAgICAgICAgLy8gVE9ETzogY291bGQgYmUgbW9yZSBlZmZpY2llbnQuIFBvaW50Q2xvdWQgcGVyIGxheWVyP1xyXG5cclxuICAgICAgICB2YXIgbnVtUG9pbnRzID0gMTtcclxuXHJcbiAgICAgICAgdmFyIGNvbG9yID0gZ2V0Q29sb3IoZW50aXR5LCBkYXRhKTtcclxuICAgICAgICB2YXIgY29sb3JzID0gbmV3IEZsb2F0MzJBcnJheSggbnVtUG9pbnRzKjMgKTtcclxuICAgICAgICBjb2xvcnNbMF0gPSBjb2xvci5yO1xyXG4gICAgICAgIGNvbG9yc1sxXSA9IGNvbG9yLmc7XHJcbiAgICAgICAgY29sb3JzWzJdID0gY29sb3IuYjtcclxuXHJcbiAgICAgICAgZ2VvbWV0cnkuY29sb3JzID0gY29sb3JzO1xyXG4gICAgICAgIGdlb21ldHJ5LmNvbXB1dGVCb3VuZGluZ0JveCgpO1xyXG5cclxuICAgICAgICBtYXRlcmlhbCA9IG5ldyBUSFJFRS5Qb2ludHNNYXRlcmlhbCggeyBzaXplOiAwLjA1LCB2ZXJ0ZXhDb2xvcnM6IFRIUkVFLlZlcnRleENvbG9ycyB9ICk7XHJcbiAgICAgICAgcG9pbnQgPSBuZXcgVEhSRUUuUG9pbnRzKGdlb21ldHJ5LCBtYXRlcmlhbCk7XHJcbiAgICAgICAgc2NlbmUuYWRkKHBvaW50KTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBkcmF3QmxvY2soZW50aXR5LCBkYXRhKSB7XHJcbiAgICAgICAgdmFyIGJsb2NrID0gZGF0YS5ibG9ja3NbZW50aXR5Lm5hbWVdO1xyXG4gICAgICAgIFxyXG4gICAgICAgIGlmICghYmxvY2suZW50aXRpZXMpIHJldHVybiBudWxsO1xyXG5cclxuICAgICAgICB2YXIgZ3JvdXAgPSBuZXcgVEhSRUUuT2JqZWN0M0QoKVxyXG4gICAgICAgIFxyXG4gICAgICAgIGlmKGVudGl0eS54U2NhbGUpIGdyb3VwLnNjYWxlLnggPSBlbnRpdHkueFNjYWxlO1xyXG4gICAgICAgIGlmKGVudGl0eS55U2NhbGUpIGdyb3VwLnNjYWxlLnkgPSBlbnRpdHkueVNjYWxlO1xyXG5cclxuICAgICAgICBpZihlbnRpdHkucm90YXRpb24pIHtcclxuICAgICAgICAgICAgZ3JvdXAucm90YXRpb24ueiA9IGVudGl0eS5yb3RhdGlvbiAqIE1hdGguUEkgLyAxODA7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZihlbnRpdHkucG9zaXRpb24pIHtcclxuICAgICAgICAgICAgZ3JvdXAucG9zaXRpb24ueCA9IGVudGl0eS5wb3NpdGlvbi54O1xyXG4gICAgICAgICAgICBncm91cC5wb3NpdGlvbi55ID0gZW50aXR5LnBvc2l0aW9uLnk7XHJcbiAgICAgICAgICAgIGdyb3VwLnBvc2l0aW9uLnogPSBlbnRpdHkucG9zaXRpb24uejtcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IGJsb2NrLmVudGl0aWVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBjaGlsZEVudGl0eSA9IGRyYXdFbnRpdHkoYmxvY2suZW50aXRpZXNbaV0sIGRhdGEsIGdyb3VwKTtcclxuICAgICAgICAgICAgaWYoY2hpbGRFbnRpdHkpIGdyb3VwLmFkZChjaGlsZEVudGl0eSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gZ3JvdXA7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZ2V0Q29sb3IoZW50aXR5LCBkYXRhKSB7XHJcbiAgICAgICAgdmFyIGNvbG9yID0gMHgwMDAwMDA7IC8vZGVmYXVsdFxyXG4gICAgICAgIGlmKGVudGl0eS5jb2xvcikgY29sb3IgPSBlbnRpdHkuY29sb3I7XHJcbiAgICAgICAgZWxzZSBpZihkYXRhLnRhYmxlcyAmJiBkYXRhLnRhYmxlcy5sYXllciAmJiBkYXRhLnRhYmxlcy5sYXllci5sYXllcnNbZW50aXR5LmxheWVyXSlcclxuICAgICAgICAgICAgY29sb3IgPSBkYXRhLnRhYmxlcy5sYXllci5sYXllcnNbZW50aXR5LmxheWVyXS5jb2xvcjtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgaWYoY29sb3IgPT0gbnVsbCB8fCBjb2xvciA9PT0gMHhmZmZmZmYpIHtcclxuICAgICAgICAgICAgY29sb3IgPSAweDAwMDAwMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGNvbG9yO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGNyZWF0ZUxpbmVUeXBlU2hhZGVycyhkYXRhKSB7XHJcbiAgICAgICAgdmFyIGx0eXBlLCB0eXBlO1xyXG4gICAgICAgIGlmKCFkYXRhLnRhYmxlcyB8fCAhZGF0YS50YWJsZXMubGluZVR5cGUpIHJldHVybjtcclxuICAgICAgICB2YXIgbHR5cGVzID0gZGF0YS50YWJsZXMubGluZVR5cGUubGluZVR5cGVzO1xyXG5cclxuICAgICAgICBmb3IodHlwZSBpbiBsdHlwZXMpIHtcclxuICAgICAgICAgICAgbHR5cGUgPSBsdHlwZXNbdHlwZV07XHJcbiAgICAgICAgICAgIGlmKCFsdHlwZS5wYXR0ZXJuKSBjb250aW51ZTtcclxuICAgICAgICAgICAgbHR5cGUubWF0ZXJpYWwgPSBjcmVhdGVEYXNoZWRMaW5lU2hhZGVyKGx0eXBlLnBhdHRlcm4pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBjcmVhdGVEYXNoZWRMaW5lU2hhZGVyKHBhdHRlcm4pIHtcclxuICAgICAgICB2YXIgaSxcclxuICAgICAgICAgICAgZGFzaGVkTGluZVNoYWRlciA9IHt9LFxyXG4gICAgICAgICAgICB0b3RhbExlbmd0aCA9IDAuMDtcclxuXHJcbiAgICAgICAgZm9yKGkgPSAwOyBpIDwgcGF0dGVybi5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB0b3RhbExlbmd0aCArPSBNYXRoLmFicyhwYXR0ZXJuW2ldKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGRhc2hlZExpbmVTaGFkZXIudW5pZm9ybXMgPSBUSFJFRS5Vbmlmb3Jtc1V0aWxzLm1lcmdlKFtcclxuXHJcbiAgICAgICAgICAgIFRIUkVFLlVuaWZvcm1zTGliWyAnY29tbW9uJyBdLFxyXG4gICAgICAgICAgICBUSFJFRS5Vbmlmb3Jtc0xpYlsgJ2ZvZycgXSxcclxuXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICdwYXR0ZXJuJzogeyB0eXBlOiAnZnYxJywgdmFsdWU6IHBhdHRlcm4gfSxcclxuICAgICAgICAgICAgICAgICdwYXR0ZXJuTGVuZ3RoJzogeyB0eXBlOiAnZicsIHZhbHVlOiB0b3RhbExlbmd0aCB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgXSk7XHJcblxyXG4gICAgICAgIGRhc2hlZExpbmVTaGFkZXIudmVydGV4U2hhZGVyID0gW1xyXG4gICAgICAgICAgICAnYXR0cmlidXRlIGZsb2F0IGxpbmVEaXN0YW5jZTsnLFxyXG5cclxuICAgICAgICAgICAgJ3ZhcnlpbmcgZmxvYXQgdkxpbmVEaXN0YW5jZTsnLFxyXG5cclxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbICdjb2xvcl9wYXJzX3ZlcnRleCcgXSxcclxuXHJcbiAgICAgICAgICAgICd2b2lkIG1haW4oKSB7JyxcclxuXHJcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyAnY29sb3JfdmVydGV4JyBdLFxyXG5cclxuICAgICAgICAgICAgJ3ZMaW5lRGlzdGFuY2UgPSBsaW5lRGlzdGFuY2U7JyxcclxuXHJcbiAgICAgICAgICAgICdnbF9Qb3NpdGlvbiA9IHByb2plY3Rpb25NYXRyaXggKiBtb2RlbFZpZXdNYXRyaXggKiB2ZWM0KCBwb3NpdGlvbiwgMS4wICk7JyxcclxuXHJcbiAgICAgICAgICAgICd9J1xyXG4gICAgICAgIF0uam9pbignXFxuJyk7XHJcblxyXG4gICAgICAgIGRhc2hlZExpbmVTaGFkZXIuZnJhZ21lbnRTaGFkZXIgPSBbXHJcbiAgICAgICAgICAgICd1bmlmb3JtIHZlYzMgZGlmZnVzZTsnLFxyXG4gICAgICAgICAgICAndW5pZm9ybSBmbG9hdCBvcGFjaXR5OycsXHJcblxyXG4gICAgICAgICAgICAndW5pZm9ybSBmbG9hdCBwYXR0ZXJuWycgKyBwYXR0ZXJuLmxlbmd0aCArICddOycsXHJcbiAgICAgICAgICAgICd1bmlmb3JtIGZsb2F0IHBhdHRlcm5MZW5ndGg7JyxcclxuXHJcbiAgICAgICAgICAgICd2YXJ5aW5nIGZsb2F0IHZMaW5lRGlzdGFuY2U7JyxcclxuXHJcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyAnY29sb3JfcGFyc19mcmFnbWVudCcgXSxcclxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbICdmb2dfcGFyc19mcmFnbWVudCcgXSxcclxuXHJcbiAgICAgICAgICAgICd2b2lkIG1haW4oKSB7JyxcclxuXHJcbiAgICAgICAgICAgICdmbG9hdCBwb3MgPSBtb2QodkxpbmVEaXN0YW5jZSwgcGF0dGVybkxlbmd0aCk7JyxcclxuXHJcbiAgICAgICAgICAgICdmb3IgKCBpbnQgaSA9IDA7IGkgPCAnICsgcGF0dGVybi5sZW5ndGggKyAnOyBpKysgKSB7JyxcclxuICAgICAgICAgICAgJ3BvcyA9IHBvcyAtIGFicyhwYXR0ZXJuW2ldKTsnLFxyXG4gICAgICAgICAgICAnaWYoIHBvcyA8IDAuMCApIHsnLFxyXG4gICAgICAgICAgICAnaWYoIHBhdHRlcm5baV0gPiAwLjAgKSB7JyxcclxuICAgICAgICAgICAgJ2dsX0ZyYWdDb2xvciA9IHZlYzQoMS4wLCAwLjAsIDAuMCwgb3BhY2l0eSApOycsXHJcbiAgICAgICAgICAgICdicmVhazsnLFxyXG4gICAgICAgICAgICAnfScsXHJcbiAgICAgICAgICAgICdkaXNjYXJkOycsXHJcbiAgICAgICAgICAgICd9JyxcclxuXHJcbiAgICAgICAgICAgICd9JyxcclxuXHJcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyAnY29sb3JfZnJhZ21lbnQnIF0sXHJcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyAnZm9nX2ZyYWdtZW50JyBdLFxyXG5cclxuICAgICAgICAgICAgJ30nXHJcbiAgICAgICAgXS5qb2luKCdcXG4nKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIGRhc2hlZExpbmVTaGFkZXI7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZmluZEV4dGVudHMoc2NlbmUpIHsgXHJcbiAgICAgICAgZm9yKHZhciBjaGlsZCBvZiBzY2VuZS5jaGlsZHJlbikge1xyXG4gICAgICAgICAgICB2YXIgbWluWCwgbWF4WCwgbWluWSwgbWF4WTtcclxuICAgICAgICAgICAgaWYoY2hpbGQucG9zaXRpb24pIHtcclxuICAgICAgICAgICAgICAgIG1pblggPSBNYXRoLm1pbihjaGlsZC5wb3NpdGlvbi54LCBtaW5YKTtcclxuICAgICAgICAgICAgICAgIG1pblkgPSBNYXRoLm1pbihjaGlsZC5wb3NpdGlvbi55LCBtaW5ZKTtcclxuICAgICAgICAgICAgICAgIG1heFggPSBNYXRoLm1heChjaGlsZC5wb3NpdGlvbi54LCBtYXhYKTtcclxuICAgICAgICAgICAgICAgIG1heFkgPSBNYXRoLm1heChjaGlsZC5wb3NpdGlvbi55LCBtYXhZKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHsgbWluOiB7IHg6IG1pblgsIHk6IG1pblkgfSwgbWF4OiB7IHg6IG1heFgsIHk6IG1heFkgfX07XHJcbiAgICB9XHJcblxyXG59XHJcblxyXG5cclxuLy8gU2hvdy9IaWRlIGhlbHBlcnMgZnJvbSBodHRwczovL3BsYWluanMuY29tL2phdmFzY3JpcHQvZWZmZWN0cy9oaWRlLW9yLXNob3ctYW4tZWxlbWVudC00Mi9cclxuLy8gZ2V0IHRoZSBkZWZhdWx0IGRpc3BsYXkgc3R5bGUgb2YgYW4gZWxlbWVudFxyXG5mdW5jdGlvbiBkZWZhdWx0RGlzcGxheSh0YWcpIHtcclxuICAgIHZhciBpZnJhbWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpZnJhbWUnKTtcclxuICAgIGlmcmFtZS5zZXRBdHRyaWJ1dGUoJ2ZyYW1lYm9yZGVyJywgMCk7XHJcbiAgICBpZnJhbWUuc2V0QXR0cmlidXRlKCd3aWR0aCcsIDApO1xyXG4gICAgaWZyYW1lLnNldEF0dHJpYnV0ZSgnaGVpZ2h0JywgMCk7XHJcbiAgICBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuYXBwZW5kQ2hpbGQoaWZyYW1lKTtcclxuXHJcbiAgICB2YXIgZG9jID0gKGlmcmFtZS5jb250ZW50V2luZG93IHx8IGlmcmFtZS5jb250ZW50RG9jdW1lbnQpLmRvY3VtZW50O1xyXG5cclxuICAgIC8vIElFIHN1cHBvcnRcclxuICAgIGRvYy53cml0ZSgpO1xyXG4gICAgZG9jLmNsb3NlKCk7XHJcblxyXG4gICAgdmFyIHRlc3RFbCA9IGRvYy5jcmVhdGVFbGVtZW50KHRhZyk7XHJcbiAgICBkb2MuZG9jdW1lbnRFbGVtZW50LmFwcGVuZENoaWxkKHRlc3RFbCk7XHJcbiAgICB2YXIgZGlzcGxheSA9ICh3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSA/IGdldENvbXB1dGVkU3R5bGUodGVzdEVsLCBudWxsKSA6IHRlc3RFbC5jdXJyZW50U3R5bGUpLmRpc3BsYXlcclxuICAgIGlmcmFtZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGlmcmFtZSk7XHJcbiAgICByZXR1cm4gZGlzcGxheTtcclxufVxyXG5cclxuLy8gYWN0dWFsIHNob3cvaGlkZSBmdW5jdGlvbiB1c2VkIGJ5IHNob3coKSBhbmQgaGlkZSgpIGJlbG93XHJcbmZ1bmN0aW9uIHNob3dIaWRlKGVsLCBzaG93KSB7XHJcbiAgICB2YXIgdmFsdWUgPSBlbC5nZXRBdHRyaWJ1dGUoJ2RhdGEtb2xkZGlzcGxheScpLFxyXG4gICAgZGlzcGxheSA9IGVsLnN0eWxlLmRpc3BsYXksXHJcbiAgICBjb21wdXRlZERpc3BsYXkgPSAod2luZG93LmdldENvbXB1dGVkU3R5bGUgPyBnZXRDb21wdXRlZFN0eWxlKGVsLCBudWxsKSA6IGVsLmN1cnJlbnRTdHlsZSkuZGlzcGxheTtcclxuXHJcbiAgICBpZiAoc2hvdykge1xyXG4gICAgICAgIGlmICghdmFsdWUgJiYgZGlzcGxheSA9PT0gJ25vbmUnKSBlbC5zdHlsZS5kaXNwbGF5ID0gJyc7XHJcbiAgICAgICAgaWYgKGVsLnN0eWxlLmRpc3BsYXkgPT09ICcnICYmIChjb21wdXRlZERpc3BsYXkgPT09ICdub25lJykpIHZhbHVlID0gdmFsdWUgfHwgZGVmYXVsdERpc3BsYXkoZWwubm9kZU5hbWUpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICBpZiAoZGlzcGxheSAmJiBkaXNwbGF5ICE9PSAnbm9uZScgfHwgIShjb21wdXRlZERpc3BsYXkgPT0gJ25vbmUnKSlcclxuICAgICAgICAgICAgZWwuc2V0QXR0cmlidXRlKCdkYXRhLW9sZGRpc3BsYXknLCAoY29tcHV0ZWREaXNwbGF5ID09ICdub25lJykgPyBkaXNwbGF5IDogY29tcHV0ZWREaXNwbGF5KTtcclxuICAgIH1cclxuICAgIGlmICghc2hvdyB8fCBlbC5zdHlsZS5kaXNwbGF5ID09PSAnbm9uZScgfHwgZWwuc3R5bGUuZGlzcGxheSA9PT0gJycpXHJcbiAgICAgICAgZWwuc3R5bGUuZGlzcGxheSA9IHNob3cgPyB2YWx1ZSB8fCAnJyA6ICdub25lJztcclxufVxyXG5cclxuLy8gaGVscGVyIGZ1bmN0aW9uc1xyXG5mdW5jdGlvbiBzaG93KGVsKSB7IHNob3dIaWRlKGVsLCB0cnVlKTsgfVxyXG5mdW5jdGlvbiBoaWRlKGVsKSB7IHNob3dIaWRlKGVsKTsgfVxyXG5cclxuXHJcblxyXG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///1\n")}])});